<!DOCTYPE html>
<html>
	

<head>
	<title>Mark S. Rasmussen</title>
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
	<meta charset="UTF-8" />
	<meta property="og:locale" content="en_US" />
	<meta property="og:type" content="website" />
	<meta name="google-site-verification" content="alt7-wfK3ZujMQ4D0jYNd0yC5LGetGdqBlBmZsqQlVw" />
	<meta content="article" property="og:type">
<meta content="Mark S. Rasmussen" property="og:title">
<meta content="http://improve.dk/page/19/" property="og:url">
<meta property="og:image">
<meta content="Mark S. Rasmussen" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
	<link rel="alternative" href="http://feeds.feedburner.com/Improvedk" title="Mark S. Rasmussen" type="application/atom+xml">
	<script src="/js/combined.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-2479580-1', 'improve.dk');
		ga('require', 'displayfeatures');
		ga('send', 	'pageview');
	</script>
	<link rel="stylesheet" href="/css/style.css" type="text/css" />
</head>
	<body>
		<div id="headerline"></div>
	
		<header>
			<div class="wrapper">
				<div id="title">
					<a href="/">Mark S. Rasmussen</a> <span>improve.dk</span>
				</div>
				
				<nav>
					<ul class="normal">
						<li class="navicon"></li>
						<li><a href="/about-me/">About Me</a></li>
					</ul>
				</nav>
				
				<ul id="sharing">
					<li><a href="mailto:mark@improve.dk" id="shareat"></a></li>
					<li><a href="http://feeds.feedburner.com/Improvedk" id="rssfeed"></a></li>
					<li><a href="https://twitter.com/improvedk" id="sharetwitter"></a></li>
					<li><a href="https://github.com/improvedk" id="sharegithub"></a></li>
					<li><a href="https://www.linkedin.com/in/markrasmussen/" id="sharelinkedin"></a></li>
				</ul>

				<div class="clear"></div>
				
				<div id="naviconcontent">
					<ul class="mobile">
						<li>
							Pages
							<ul class="pages"></ul>
						</li>
						<li>
							Categories
							<ul class="categories"></ul>
						</li>
						<li>
							Archive
							<ul class="archive"></ul>
						</li>
					</ul>
				</div>
			</div>
		</header>

		<div id="mainwrapper">
			<div id="contentwrapper">
				<div id="content">
				
					
	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jun</span>
			<span class="day">10</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/" title="Creating a .NET Bootstrapped Installer Using NSIS" rel="bookmark">Creating a .NET Bootstrapped Installer Using NSIS</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>If you have ever deployed .NET windows applications, you have without doubt tried the Visual Studio Install project type. The Install project will create .MSI install applications for you, they’re great for basic installations, but nothing more than that. The .NET bootstrapper is quite lacking, at times it won’t be able to find the framework download file as it’s changed it’s location, at other times it’s not able to download it. And finally, if it does determine that the user needs the framework, it’s shown in an ugly uncustomizable GUI.</p>
<a id="more"></a>

<p>I’ve looked for an alternative, I’d prefer not to pay for using some of the well established installers such as Wise, InstallShield, ActiveInstall and so forth. What I found is a remnant of WinAmp, the <a href="http://nsis.sourceforge.net/Main_Page" target="_blank">NSIS (Nullsoft Scriptable Install System) project</a>.</p>
<p>NSIS is both free and open source and it’s very much community driven. There are a plethora of plugins available for all sorts of different tasks, and of course you can write your own plugins for special needs.</p>
<p>I won’t delve too deeply into why you should choose NSIS over any of the competitors, instead I’ll show you a step by step guide of how to create an NSIS installer that bootstraps the .NET 2.0 framework as well as running custom install and uninstall actions in .NET code.</p>
<p>You will need two tools. The first (and actually the only required tool) is NSIS itself: <a href="http://nsis.sourceforge.net/Main_Page" target="_blank">Download NSIS from nsis.sourceforge.net</a>. While you can edit the install script in any text editor, using an IDE like HM NIS Edit (HMNE) makes it a whole lot easier: <a href="http://hmne.sourceforge.net/" target="_blank">Download HMNE from hmne.sourceforge.net</a>.</p>
<p>Let’s first create the simple application that we will be installing. It doesn’t really matter what it is, in this example I’ve made a single Windows Forms Application:</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_1_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_1_2.jpg" style="max-height: 250px"/></a></div></div>

<p>Now let’s start up HMNE. Click File -&gt; New Script From Wizard. Fill in the relevant application date on the first page.</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_2_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_2_2.jpg" style="max-height: 250px"/></a></div></div>

<p>You may choose a custom icon for the installer, the default icon is an NSIS standard icon. You can also choose the resulting installation files name as well as it’s output location. If no location is specified, it will be outputted to the location that contains our script file. A great feature of NSIS is that it’s got localized versions for a lot of different languages built in, simply select the languages that the user should be able to select and the installer will automatically be localized. You can choose a couple of different GUIs, I personally prefer the Modern one. As for compression, in my tests the LZMA compression works the best, though compression time and CPU usage might be a factor for very large projects.</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_3_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_3_2.jpg" style="max-height: 250px"/></a></div></div>

<p>Now you specify where you want your application to be installed, notice the general use of variables like $PROGRAMFILES, $NSISDIR, $INSTDIR and so forth. You can also optionally choose a license file that the user must accept to continue the installation.</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_4_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_4_2.jpg" style="max-height: 250px"/></a></div></div>

<p>Now you can setup the actual files that will be installed as part of the project. You cannot select a whole project output as you can in the Visual Studio Install project, instead you must manually select the files that should be installed, usually from the Debug/Release directories of your project(s).</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_5_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_5_2.jpg" style="max-height: 250px"/></a></div></div>

<p>Optionally you can select which links you want to be placed in the application program group in the start menu, if such one should be created at all.</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_6_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_6_2.jpg" style="max-height: 250px"/></a></div></div>

<p>When the installation is done, the user can choose to view the Readme file and/or start the application - that is, if you specify an application and/or a readme file.</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_7_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_7_2.jpg" style="max-height: 250px"/></a></div></div>

<p>Finally we can choose to include an uninstaller, as well as specifying our custom uninstallation confirmation and report texts. If no custom text is specified, the default texts will be used.</p>
<p>When the wizard finishes, make sure to click “Save script” and “Convert file paths to relative paths”.</p>
<p>Finally the install script is made and ready to run. Press Ctrl+9 to compile the script. If everything succeeds, you’ll see the Setup.exe file in the same directory as the one where you saved the install script. I will not be going over the various commands and settings that are being set in the script, for that I strongly recommend the excellent built in help documents, as well as the <a href="http://forums.winamp.com/forumdisplay.php?s=&amp;forumid=65" target="_blank">WinAmp NSIS forums</a>. Instead I’ll focus on how to bootstrap the .NET Framework 2.0 and how to run custom install and uninstall actions.</p>
<p>Add these three lines to the top of your nsi file, they include some functions that we will need:</p>
<figure class="highlight nsi"><pre>; Script generated <span class="keyword">by</span> <span class="operator">the</span> HM NIS Edit Script Wizard.
!<span class="built_in">include</span> WordFunc.nsh
!insertmacro VersionCompare
!<span class="built_in">include</span> LogicLib.nsh
</pre></figure>

<p>Add this line right above the .onInit function, it makes a variable (untyped) that’ll contain a Yes/No value, depending on whether we need to install the .NET Framework or not.</p>
<figure class="highlight nsi"><pre><span class="keyword">Var</span> InstallDotNET
</pre></figure>

<p>Now modify the .onInit function so it matches the below, as well as adding the GetDotNETVersion function. First we ask the user what language they want to continue in (!insertmacro MUI_LANGDLL_DISPLAY). After that we initialize the InstallDotNET variable to “No”. Depending on the result of the GetDotNETVersion we tell the user that we need to install the framework, either because the user does not have the framework at all, or because the version is less than 2.0. We won’t actually install the framework yet, we’ll just remember whether we have to or not.</p>
<figure class="highlight nsi"><pre>Function .onInit
  !insertmacro MUI_LANGDLL_DISPLAY

  ; Check .NET version
  StrCpy <span class="variable">$InstallDotNET</span> <span class="string">"No"</span>
  Call GetDotNETVersion
  Pop <span class="variable">$0</span>

  <span class="variable">${If}</span> <span class="variable">$0</span> == <span class="string">"not found"</span>
        StrCpy <span class="variable">$InstallDotNET</span> <span class="string">"Yes"</span>
  	MessageBox MB_OK|MB_ICONINFORMATION <span class="string">"<span class="subst">${PRODUCT_NAME}</span> requires that the .NET Framework 2.0 is installed. The .NET Framework will be downloaded and installed automatically during installation of <span class="subst">${PRODUCT_NAME}</span>."</span>
   	Return
  <span class="variable">${EndIf}</span>

  StrCpy <span class="variable">$0</span> <span class="variable">$0</span> <span class="string">""</span> <span class="number">1</span> <span class="comment"># skip "v"</span>

  <span class="variable">${VersionCompare}</span> <span class="variable">$0</span> <span class="string">"2.0"</span> <span class="variable">$1</span>
  <span class="variable">${If}</span> <span class="variable">$1</span> == <span class="number">2</span>
        StrCpy <span class="variable">$InstallDotNET</span> <span class="string">"Yes"</span>
  	MessageBox MB_OK|MB_ICONINFORMATION <span class="string">"<span class="subst">${PRODUCT_NAME}</span> requires that the .NET Framework 2.0 is installed. The .NET Framework will be downloaded and installed automatically during installation of <span class="subst">${PRODUCT_NAME}</span>."</span>
   	Return
  <span class="variable">${EndIf}</span>
FunctionEnd

Function GetDotNETVersion
	Push <span class="variable">$0</span>
	Push <span class="variable">$1</span>

	System::Call <span class="string">"mscoree::GetCORVersion(w .r0, i <span class="subst">${NSIS_MAX_STRLEN}</span>, <span class="variable">*i</span>) i .r1"</span>
	StrCmp <span class="variable">$1</span> <span class="string">"error"</span> <span class="number">0</span> +<span class="number">2</span>
	StrCpy <span class="variable">$0</span> <span class="string">"not found"</span>

	Pop <span class="variable">$1</span>
	Exch <span class="variable">$0</span>
FunctionEnd
</pre></figure>

<p>Before we continue, you’ll have to <a href="http://nsis.sourceforge.net/Inetc_plug-in" target="_blank">install the InetC plugin</a>.</p>
<p>Now find the “MainSection” section (depending on what you called it in the wizard).</p>
<p>Modify the section so it looks like the below. Your file names and amount may vary, the primary part of our concern is the first part. It will test whether the $InstallDotNET variable implies that we have to install the framework. If it does, it’ll hide the usual GUI elements of the installer and start the download of the .NET Framework from any URL you specify, this could be the official download URL or a location you host yourself. If the user cancels the download we’ll delete the half-finished file and abort. Otherwise we’ll execute the dotnetfx.exe file and wait for it to complete (hence we’ll now have the .NET Framework 2.0). After having installed the framework we delete the dotnetfx.exe file again. Finally we show the GUI again.</p>
<figure class="highlight nsi"><pre>Section <span class="string">"MainSection"</span> SEC01
  SetOutPath <span class="string">"<span class="variable">$INSTDIR</span>"</span>
  SetOverwrite ifnewer

  ; Get .NET <span class="keyword">if</span> required
  <span class="variable">${If}</span> <span class="variable">$InstallDotNET</span> == <span class="string">"Yes"</span>
     SetDetailsView hide
     inetc::get /caption <span class="string">"Downloading .NET Framework 2.0"</span> /canceltext <span class="string">"Cancel"</span> <span class="string">"http://www.url_of_the_dotnetfx.exe_file"</span> <span class="string">"<span class="variable">$INSTDIRdotnetfx</span>.exe"</span> /end
     Pop <span class="variable">$1</span>

     <span class="variable">${If}</span> <span class="variable">$1</span> != <span class="string">"OK"</span>
           Delete <span class="string">"<span class="variable">$INSTDIRdotnetfx</span>.exe"</span>
           Abort <span class="string">"Installation cancelled."</span>
     <span class="variable">${EndIf}</span>

     ExecWait <span class="string">"<span class="variable">$INSTDIRdotnetfx</span>.exe"</span>
     Delete <span class="string">"<span class="variable">$INSTDIRdotnetfx</span>.exe"</span>

     SetDetailsView show
  <span class="variable">${EndIf}</span> 

  File <span class="string">"InstallbinDebugInstall.exe"</span>

  File <span class="string">"InstallbinDebugUninstall.exe"</span>

  File <span class="string">"MyApplicationbinDebugMyApplication.exe"</span>
  CreateDirectory <span class="string">"<span class="variable">$SMPROGRAMSMy</span> application"</span>
  CreateShortCut <span class="string">"<span class="variable">$SMPROGRAMSMy</span> applicationMy application.lnk"</span> <span class="string">"<span class="variable">$INSTDIRMyApplication</span>.exe"</span>
  CreateShortCut <span class="string">"<span class="variable">$DESKTOPMy</span> application.lnk"</span> <span class="string">"<span class="variable">$INSTDIRMyApplication</span>.exe"</span>
SectionEnd
</pre></figure>

<p>Now comes the part where I’ll introduce our custom .NET install and uninstall actions. Create two new Console Application projects in the solution called Uninstall and Install, like the following:</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_9_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_9_2.jpg" style="max-height: 250px"/></a></div></div>

<p>Add the below function to your code, it’ll run the Install.exe file after the installation has successfully completed:</p>
<figure class="highlight nsi"><pre><span class="title">Function</span> .<span class="built_in">on</span>InstSuccess
         ExecWait <span class="string">"<span class="variable">$InstDirInstall</span>.exe"</span>
FunctionEnd
</pre></figure>

<p>Locate the “Section Uninstall” part and add the following line as the very first:</p>
<figure class="highlight nsi"><pre>ExecWait <span class="string">"<span class="variable">$InstDirUninstall</span>.exe"</span>
</pre></figure>

<p>Make sure to add both Install.exe and Uninstall.exe to the list of files that will be installed, in the Main Section. It will run the Uninstall.exe application before anything else, and wait for it to finish before continuing. After it’s done we’ll delete all the installed files, including the Install and Uninstall.exe applications - remember to add those to file deletions manually, following the syntax of the other file deletions.</p>
<p>Now press Ctrl+9 to build the installer, and look at it run in all of its awesomeness:</p>
<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_10_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_10_2.jpg" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_11_2.jpg" class="fancy"><img src="/creating-a-dotnet-bootstrapped-installer-using-nsis/nsis_11_2.jpg" style="max-height: 250px"/></a></div></div>

<p>After having downloaded the .NET Framework 2.0, it’ll start the .NET installer and run it through as usual, the installation will continue as soon as the .NET installer finishes. There is currently no check for whether the user cancels the .NET installation midways or if it fails. A simple check could be made right afterwards by simple calling the GetDotNETVersion function again like we did just before, if it fails, the user hasn’t installed .NET for some unknown reason and we’ll have to abort.</p>
<p>You can see <a href="http://www.improve.dk/downloads/InstallScript.txt" target="_blank">my complete install script here</a>. Download and rename to *.nsi to compile it.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">14</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/cascading-windows/" title="Cascading Windows Using PInvoke" rel="bookmark">Cascading Windows Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>In Photoshop we often work with multiple windows open. They can be cascaded to more easily be able to view the different windows and tell them apart. There’s an API function that does the same to any windows you specify, you can even define the rectangle where they should be cascaded within.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System.Drawing;
<span class="keyword">using</span> System.Collections;

namespace Cascading_Windows
{
	class Program
	{
		<span class="comment">// The CascadeWindows function cascades the specified child windows of the specified parent window. It can be used to</span>
		<span class="comment">// cascade all windows (as in this example) or just the child windows of a specific window by passing in a handle to that</span>
		<span class="comment">// window. You can also define the rectangle wherein they should be cascaded.</span>
		<span class="comment">// See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/animatewindow.asp</span>
		<span class="comment">// for full documentation.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">CascadeWindows</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> wHow, <span class="keyword">ref</span> Rectangle lpRect, <span class="keyword">int</span> cKids, <span class="keyword">ref</span> ArrayList lpKids);

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// As the function expects references to both a Rectangle and an ArrayList, we'll have to hack a couple of null values</span>
			<span class="comment">// as we can't pass null into the function.</span>
			Rectangle nilRect = Rectangle.Empty;
			ArrayList nilList = <span class="keyword">null</span>;

			<span class="comment">// Cascade all windows that are children of the Desktop (handle = 0).</span>
			CascadeWindows(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">ref</span> nilRect, <span class="number">0</span>, <span class="keyword">ref</span> nilList);

			Console.Read();
		}
	}
}
</pre></figure>

<p>And the result:</p>
<p><em>Having three monitors generates quite a large screenshot so I’ll leave this one up for you to try / your imagination :)</em></p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">13</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/animating-windows/" title="Animating Windows Using PInvoke" rel="bookmark">Animating Windows Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Let’s be a bit more graphic. This time I’ll show you how to use the Windows API to make your forms fade in/out, slide in from the side or do various other animations. For this example we’ll have to use a Windows Forms project as we have to utilize a Form object in the example.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.ComponentModel;
<span class="keyword">using</span> System.Data;
<span class="keyword">using</span> System.Drawing;
<span class="keyword">using</span> System.Text;
<span class="keyword">using</span> System.Windows.Forms;
<span class="keyword">using</span> System.Runtime.InteropServices;

namespace Animating_windows
{
	<span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> Form1 : Form
	{
		<span class="comment">// The possible AW flags for use with the AnimateWindow function.</span>
		<span class="keyword">public</span> <span class="keyword">enum</span> AW : <span class="keyword">int</span>
		{
			SLIDE = <span class="number">262144</span>,
			ACTIVATE = <span class="number">131072</span>,
			BLEND = <span class="number">524288</span>,
			HIDE = <span class="number">65536</span>,
			CENTER = <span class="number">16</span>,
			HOR_POSITIVE = <span class="number">1</span>,
			HOR_NEGATIVE = <span class="number">2</span>,
			VER_POSITIVE = <span class="number">4</span>,
			VER_NEGATIVE = <span class="number">8</span>
		}

		<span class="comment">// The AnimateWindow function enables you to produce special effects when showing or hiding windows. The hWnd parameter</span>
		<span class="comment">// is the handle to the window - note that this window HAS to be in the same thread as the thread calling the AnimateWindow</span>
		<span class="comment">// function - thus the windows project so we have a Form to experiment with. The time flag is the duration of the</span>
		<span class="comment">// animation, and finally the flags parameter sets the type of animation to perform.</span>
		<span class="comment">// See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/animatewindow.asp</span>
		<span class="comment">// for full documentation.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">AnimateWindow</span>(IntPtr hWnd, <span class="keyword">int</span> time, <span class="keyword">int</span> flags);

		<span class="keyword">public</span> <span class="title">Form1</span>()
		{
			InitializeComponent();
		}

		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="keyword">object</span> sender, EventArgs e)
		{
			<span class="comment">// Fade in the form over a period of 3 seconds.</span>
			AnimateWindow(<span class="keyword">this</span>.Handle, <span class="number">3000</span>, (<span class="keyword">int</span>)AW.BLEND);

			<span class="comment">// Hide the form so we can perform the next animation.</span>
			<span class="keyword">this</span>.Hide();

			<span class="comment">// Make the window expand outward.</span>
			AnimateWindow(<span class="keyword">this</span>.Handle, <span class="number">3000</span>, (<span class="keyword">int</span>)AW.CENTER);

			<span class="comment">// And collapse inward...</span>
			AnimateWindow(<span class="keyword">this</span>.Handle, <span class="number">3000</span>, (<span class="keyword">int</span>)AW.CENTER | (<span class="keyword">int</span>)AW.HIDE);

			<span class="comment">// Let's slide in the form from the left side to the right.</span>
			AnimateWindow(<span class="keyword">this</span>.Handle, <span class="number">3000</span>, (<span class="keyword">int</span>)AW.SLIDE | (<span class="keyword">int</span>)AW.HOR_POSITIVE);
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/animating-windows/win32_12_1_2.jpg" class="fancy"><img src="/animating-windows/win32_12_1_2.jpg" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/animating-windows/win32_12_2_2.jpg" class="fancy"><img src="/animating-windows/win32_12_2_2.jpg" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/animating-windows/win32_12_3_2.jpg" class="fancy"><img src="/animating-windows/win32_12_3_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">12</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/activating-windows/" title="Activating Windows Using PInvoke" rel="bookmark">Activating Windows Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Now we’ll see how to activate windows and sending them to the foreground. I will be using the <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">WindowFinder class</a> that I introduced in the blog <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">Finding specific windows</a>.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System.Text.RegularExpressions;

namespace Activating_windows
{
	class Program
	{
		<span class="comment">// This enumeration holds all the possible values that can be passed onto the ShowWindow function.</span>
		<span class="keyword">public</span> <span class="keyword">enum</span> SW : <span class="keyword">int</span>
		{
			HIDE = <span class="number">0</span>,
			SHOWNORMAL = <span class="number">1</span>,
			SHOWMINIMIZED = <span class="number">2</span>,
			SHOWMAXIMIZED = <span class="number">3</span>,
			SHOWNOACTIVATE = <span class="number">4</span>,
			SHOW = <span class="number">5</span>,
			MINIMIZE = <span class="number">6</span>,
			SHOWMINNOACTIVE = <span class="number">7</span>,
			SHOWNA = <span class="number">8</span>,
			RESTORE = <span class="number">9</span>,
			SHOWDEFAULT = <span class="number">10</span>
		}

		<span class="comment">// The SetForegroundWindow will activate the window, setting the window thread to the foreground thread, as</span>
		<span class="comment">// well as activating keyboard input for the specified window.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">long</span> <span class="title">SetForegroundWindow</span>(<span class="keyword">int</span> hWnd);

		<span class="comment">// The ShowWindow function can do the same as SetForegroundWindow, but it gives much greater control</span>
		<span class="comment">// over what happens, by customizing the parameters sent through the cmd parameter.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">ShowWindow</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> cmd);

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// Introduced in the "Finding specific windows" blog, we use the WindowFinder class to find all Internet Explorer main window instances.</span>
			Finding_specific_windows.WindowFinder wf = <span class="keyword">new</span> Finding_specific_windows.WindowFinder();
			wf.FindWindows(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Regex(<span class="string">"- (Windows|Microsoft) Internet Explorer"</span>), <span class="keyword">new</span> Regex(<span class="string">"iexplore"</span>), <span class="keyword">new</span> Finding_specific_windows.WindowFinder.FoundWindowCallback(foundWindow));

			Console.Read();
		}

		<span class="keyword">static</span> <span class="keyword">bool</span> foundWindow(<span class="keyword">int</span> handle)
		{
			<span class="comment">// We'll activate the window by calling the SetForegroundWindow function, passing in the handle to the window.</span>
			SetForegroundWindow(handle);

			<span class="comment">// Calling the ShowWindow function with the SHOWNA parameter will put the window in the foreground,</span>
			<span class="comment">// but it won't be activated.</span>
			ShowWindow(handle, (<span class="keyword">int</span>)SW.SHOWNA);

			Console.WriteLine(<span class="string">"Window activated."</span>);

			<span class="keyword">return</span> <span class="keyword">false</span>;
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/activating-windows/win32_11_1_2.jpg" class="fancy"><img src="/activating-windows/win32_11_1_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">11</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/getting-key-state/" title="Getting Key State Using PInvoke" rel="bookmark">Getting Key State Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Here’s an example of how to retrieve the state of any keyboard key.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.InteropServices;

namespace Getting_key_state
{
	class Program
	{
		<span class="comment">// The GetAsyncKeyState takes a virtual key code as the nVirtKey parameter. It then checks on the state of</span>
		<span class="comment">// this key (down/up). The return code is either zero for up or any non-zero value for pressed,</span>
		<span class="comment">// thus it's easiest to convert the result to a boolean and use that result.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">short</span> <span class="title">GetAsyncKeyState</span>(<span class="keyword">int</span> nVirtKey);

		<span class="comment">// These are all the possible values in the VK enumeration. It covers most of the special buttons on a keyboard.</span>
		<span class="comment">// See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/WindowsUserInterface/UserInput/VirtualKeyCodes.asp</span>
		<span class="comment">// for full documentation.</span>
		<span class="keyword">public</span> <span class="keyword">enum</span> VK : <span class="keyword">int</span>
		{
			NUMPAD7 = <span class="number">0x67</span>,
			NUMPAD8 = <span class="number">0x68</span>,
			NUMPAD9 = <span class="number">0x69</span>,
			MULTIPLY = <span class="number">0x6A</span>,
			ADD = <span class="number">0x6B</span>,
			SEPARATOR = <span class="number">0x6C</span>,
			SUBTRACT = <span class="number">0x6D</span>,
			DECIMAL = <span class="number">0x6E</span>,
			DIVIDE = <span class="number">0x6F</span>,
			F1 = <span class="number">0x70</span>,
			F2 = <span class="number">0x71</span>,
			F3 = <span class="number">0x72</span>,
			F4 = <span class="number">0x73</span>,
			F5 = <span class="number">0x74</span>,
			F6 = <span class="number">0x75</span>,
			F7 = <span class="number">0x76</span>,
			F8 = <span class="number">0x77</span>,
			F9 = <span class="number">0x78</span>,
			F10 = <span class="number">0x79</span>,
			F11 = <span class="number">0x7A</span>,
			F12 = <span class="number">0x7B</span>,
			NUMLOCK = <span class="number">0x90</span>,
			SCROLL = <span class="number">0x91</span>,
			LSHIFT = <span class="number">0xA0</span>,
			RSHIFT = <span class="number">0xA1</span>,
			LCONTROL = <span class="number">0xA2</span>,
			RCONTROL = <span class="number">0xA3</span>,
			LMENU = <span class="number">0xA4</span>,
			RMENU = <span class="number">0xA5</span>,
			BACK = <span class="number">0x08</span>,
			TAB = <span class="number">0x09</span>,
			RETURN = <span class="number">0x0D</span>,
			SHIFT = <span class="number">0x10</span>,
			CONTROL = <span class="number">0x11</span>,
			MENU = <span class="number">0x12</span>,
			PAUSE = <span class="number">0x13</span>,
			CAPITAL = <span class="number">0x14</span>,
			ESCAPE = <span class="number">0x1B</span>,
			SPACE = <span class="number">0x20</span>,
			END = <span class="number">0x23</span>,
			HOME = <span class="number">0x24</span>,
			LEFT = <span class="number">0x25</span>,
			UP = <span class="number">0x26</span>,
			RIGHT = <span class="number">0x27</span>,
			DOWN = <span class="number">0x28</span>,
			PRINT = <span class="number">0x2A</span>,
			SNAPSHOT = <span class="number">0x2C</span>,
			INSERT = <span class="number">0x2D</span>,
			DELETE = <span class="number">0x2E</span>,
			LWIN = <span class="number">0x5B</span>,
			RWIN = <span class="number">0x5C</span>,
			NUMPAD0 = <span class="number">0x60</span>,
			NUMPAD1 = <span class="number">0x61</span>,
			NUMPAD2 = <span class="number">0x62</span>,
			NUMPAD3 = <span class="number">0x63</span>,
			NUMPAD4 = <span class="number">0x64</span>,
			NUMPAD5 = <span class="number">0x65</span>,
			NUMPAD6 = <span class="number">0x66</span>,
			A = <span class="number">0x41</span>,
			B = <span class="number">0x42</span>,
			C = <span class="number">0x43</span>,
			D = <span class="number">0x44</span>,
			E = <span class="number">0x45</span>,
			F = <span class="number">0x46</span>,
			G = <span class="number">0x47</span>,
			H = <span class="number">0x48</span>,
			I = <span class="number">0x49</span>,
			J = <span class="number">0x4A</span>,
			K = <span class="number">0x4B</span>,
			L = <span class="number">0x4C</span>,
			M = <span class="number">0x4D</span>,
			N = <span class="number">0x4E</span>,
			O = <span class="number">0x4F</span>,
			P = <span class="number">0x50</span>,
			Q = <span class="number">0x51</span>,
			R = <span class="number">0x52</span>,
			S = <span class="number">0x53</span>,
			T = <span class="number">0x54</span>,
			U = <span class="number">0x55</span>,
			V = <span class="number">0x56</span>,
			W = <span class="number">0x57</span>,
			X = <span class="number">0x58</span>,
			Y = <span class="number">0x59</span>,
			Z = <span class="number">0x5A</span>
		}

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// We'll call GetAsyncKeyState passing in the A keycode as a parameter.</span>
			Console.WriteLine(Convert.ToBoolean(GetAsyncKeyState((<span class="keyword">int</span>)VK.A)));

			<span class="comment">// And then we'll pass the shift keycode as a control check.</span>
			Console.WriteLine(Convert.ToBoolean(GetAsyncKeyState((<span class="keyword">int</span>)VK.SHIFT)));

			Console.ReadLine();
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/getting-key-state/win32_10_1_2.jpg" class="fancy"><img src="/getting-key-state/win32_10_1_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">11</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/minimizing-and-maximizing-windows/" title="Minimizing and Maximizing Windows Using PInvoke" rel="bookmark">Minimizing and Maximizing Windows Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>This time I will show how to maximize and minimize windows. I will be using the <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">WindowFinder class</a> that I introduced in the blog <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">Finding specific windows</a>.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.Text;
<span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System.Text.RegularExpressions;

namespace Minimizing_and_maximizing_windows
{
	class Program
	{
		<span class="comment">// The ShowWindowAsync method alters the windows show state through the nCmdShow parameter.</span>
		<span class="comment">// The nCmdShow parameter can have any of the SW values.</span>
		<span class="comment">// See http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/showwindowasync.asp</span>
		<span class="comment">// for full documentation.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">ShowWindowAsync</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> nCmdShow);

		<span class="comment">// An enumeration containing all the possible SW values.</span>
		<span class="keyword">public</span> <span class="keyword">enum</span> SW : <span class="keyword">int</span>
		{
			HIDE = <span class="number">0</span>,
			SHOWNORMAL = <span class="number">1</span>,
			SHOWMINIMIZED = <span class="number">2</span>,
			SHOWMAXIMIZED = <span class="number">3</span>,
			SHOWNOACTIVATE = <span class="number">4</span>,
			SHOW = <span class="number">5</span>,
			MINIMIZE = <span class="number">6</span>,
			SHOWMINNOACTIVE = <span class="number">7</span>,
			SHOWNA = <span class="number">8</span>,
			RESTORE = <span class="number">9</span>,
			SHOWDEFAULT = <span class="number">10</span>
		}

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// Introduced in the "Finding specific windows" blog, we use the WindowFinder class to find all Internet Explorer main window instances.</span>
			Finding_specific_windows.WindowFinder wf = <span class="keyword">new</span> Finding_specific_windows.WindowFinder();
			wf.FindWindows(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Regex(<span class="string">"- (Windows|Microsoft) Internet Explorer"</span>), <span class="keyword">new</span> Regex(<span class="string">"iexplore"</span>), <span class="keyword">new</span> Finding_specific_windows.WindowFinder.FoundWindowCallback(foundWindow));

			Console.Read();
		}

		<span class="keyword">static</span> <span class="keyword">bool</span> foundWindow(<span class="keyword">int</span> handle)
		{
			<span class="comment">// After an Internet Explorer window has been found, randomly either maximize or minimize it.</span>
			<span class="keyword">if</span> (<span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span>)
			{
				<span class="comment">// Maximize the window.</span>
				ShowWindowAsync(handle, (<span class="keyword">int</span>)SW.SHOWMAXIMIZED);

				Console.WriteLine(<span class="string">"Window maximized"</span>);
			}
			<span class="keyword">else</span>
			{
				<span class="comment">// Minimize the window.</span>
				ShowWindowAsync(handle, (<span class="keyword">int</span>)SW.MINIMIZE);

				Console.WriteLine(<span class="string">"Window minimized"</span>);
			}

			<span class="comment">// Since we return true, this will be done for any and all Internet Explorer instances.</span>
			<span class="keyword">return</span> <span class="keyword">true</span>;
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/minimizing-and-maximizing-windows/win32_9_1_2.jpg" class="fancy"><img src="/minimizing-and-maximizing-windows/win32_9_1_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">09</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/modifying-window-location-and-size/" title="Modifying Window Location and Size Using PInvoke" rel="bookmark">Modifying Window Location and Size Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Last time we saw how to obtain a windows location and size. This time I’ll show how to change a windows size and location. I will be using the <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">WindowFinder class</a> that I introduced in the blog <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">Finding specific windows</a>.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.Text;
<span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System.Text.RegularExpressions;
<span class="keyword">using</span> System.Drawing;

namespace Modifying_window_location_and_size
{
	class Program
	{
		<span class="comment">// The SetWindowPos function is used to both resize and change the location of windows. The uFlags parameter</span>
		<span class="comment">// can take any number of flags, with zero being a neutral flag, the same goes for the hWndInsertAfter parameter.</span>
		<span class="comment">// X, Y is the new location of the window, cx and cy is the new height / width of the window. Via uFlags it can</span>
		<span class="comment">// be set to ignore the new location and/or the new size of the window.</span>
		<span class="comment">// See http://msdn2.microsoft.com/en-us/library/ms633545.aspx for full documentation.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">SetWindowPos</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> hWndInsertAfter, <span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy, <span class="keyword">uint</span> uFlags);

		<span class="comment">// An enumeration containing all the possible HWND values.</span>
		<span class="keyword">public</span> <span class="keyword">enum</span> HWND : <span class="keyword">int</span>
		{
			BOTTOM = <span class="number">1</span>,
			NOTOPMOST = -<span class="number">2</span>,
			TOPMOST = -<span class="number">1</span>,
			TOP = <span class="number">0</span>
		}

		<span class="comment">// And enumeration containing all the possible SWP values.</span>
		<span class="keyword">public</span> <span class="keyword">enum</span> SWP : <span class="keyword">uint</span>
		{
			ASYNCWINDOWPOS = <span class="number">0x4000</span>,
			DEFERERASE = <span class="number">0x2000</span>,
			FRAMECHANGED = <span class="number">0x0020</span>,
			HIDEWINDOW = <span class="number">0x0080</span>,
			NOACTIVATE = <span class="number">0x0010</span>,
			NOCOPYBITS = <span class="number">0x0100</span>,
			NOMOVE = <span class="number">0x0002</span>,
			NOOWNERZORDER = <span class="number">0x0200</span>,
			NOREDRAW = <span class="number">0x0008</span>,
			NOSENDCHANGING = <span class="number">0x0400</span>,
			NOSIZE = <span class="number">0x0001</span>,
			NOZORDER = <span class="number">0x0004</span>,
			SHOWWINDOW = <span class="number">0x0040</span>
		}

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// Introduced in the "Finding specific windows" blog, we use the WindowFinder class to find all Internet Explorer main window instances.</span>
			Finding_specific_windows.WindowFinder wf = <span class="keyword">new</span> Finding_specific_windows.WindowFinder();
			wf.FindWindows(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Regex(<span class="string">"- (Windows|Microsoft) Internet Explorer"</span>), <span class="keyword">new</span> Regex(<span class="string">"iexplore"</span>), <span class="keyword">new</span> Finding_specific_windows.WindowFinder.FoundWindowCallback(foundWindow));

			Console.Read();
		}

		<span class="keyword">static</span> <span class="keyword">bool</span> foundWindow(<span class="keyword">int</span> handle)
		{
			<span class="comment">// After an Internet Explorer window has been found, relocate it to (50,50) and set it's size to 600x500px.</span>
			SetWindowPos(handle, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">600</span>, <span class="number">500</span>, <span class="number">0</span>);

			Console.WriteLine(<span class="string">"Window resized and relocated"</span>);

			<span class="comment">// Since we return true, this will be done for any and all Internet Explorer instances.</span>
			<span class="keyword">return</span> <span class="keyword">true</span>;
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/modifying-window-location-and-size/win32_8_1_2.jpg" class="fancy"><img src="/modifying-window-location-and-size/win32_8_1_2.jpg" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/modifying-window-location-and-size/win32_8_2_2.jpg" class="fancy"><img src="/modifying-window-location-and-size/win32_8_2_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">09</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/getting-window-location-and-size/" title="Getting Window Location and Size Using PInvoke" rel="bookmark">Getting Window Location and Size Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>This time I’ll show how to obtain the size and location of a window. I will be using the <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">WindowFinder class</a> that I introduced in the blog <a href="http://www.improve.dk/blog/2007/04/07/finding-specific-windows" target="_blank">Finding specific windows</a>.</p>
<a id="more"></a>

<p>Note that the location is not in relation to it’s parent windows location, it is always the absolute screen position.</p>
<figure class="highlight cs"><pre><span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System.Drawing;
<span class="keyword">using</span> System.Text.RegularExpressions;
<span class="keyword">using</span> System;
<span class="keyword">using</span> System.Text;
<span class="keyword">using</span> System.Globalization;

namespace Getting_window_location_and_size
{
	class Program
	{
		<span class="comment">// Win32 constants.</span>
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXT = <span class="number">0x000D</span>;
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXTLENGTH = <span class="number">0x000E</span>;

		<span class="comment">// Win32 functions that have all been used in previous blogs.</span>
		[DllImport(<span class="string">"User32.Dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">GetClassName</span>(<span class="keyword">int</span> hWnd, StringBuilder s, <span class="keyword">int</span> nMaxCount);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, StringBuilder lParam);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, <span class="keyword">int</span> lParam);

		<span class="comment">// The GetWindowRect function takes a handle to the window as the first parameter. The second parameter</span>
		<span class="comment">// must include a reference to a Rectangle object. This Rectangle object will then have it's values set</span>
		<span class="comment">// to the window rectangle properties.</span>
		[DllImport(<span class="string">"user32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">long</span> <span class="title">GetWindowRect</span>(<span class="keyword">int</span> hWnd, <span class="keyword">ref</span> Rectangle lpRect);

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// Introduced in the "Finding specific windows" blog, we use the WindowFinder class to find all Internet Explorer main window instances.</span>
			Finding_specific_windows.WindowFinder wf = <span class="keyword">new</span> Finding_specific_windows.WindowFinder();
			wf.FindWindows(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Regex(<span class="string">"- (Windows|Microsoft) Internet Explorer"</span>), <span class="keyword">new</span> Regex(<span class="string">"iexplore"</span>), <span class="keyword">new</span> Finding_specific_windows.WindowFinder.FoundWindowCallback(foundWindow));

			Console.Read();
		}

		<span class="keyword">static</span> <span class="keyword">bool</span> foundWindow(<span class="keyword">int</span> handle)
		{
			<span class="comment">// First we intialize an empty Rectangle object.</span>
			Rectangle rect = <span class="keyword">new</span> Rectangle();

			<span class="comment">// Then we call the GetWindowRect function, passing in a reference to the rect object.</span>
			GetWindowRect(handle, <span class="keyword">ref</span> rect);

			<span class="comment">// And then we get the resulting rectangle. The tricky part here is that this rectangle includes</span>
			<span class="comment">// not only the location of the window, but also the size, but not in the form we're used to.</span>
			Console.WriteLine(rect.ToString());

			<span class="comment">// If the window is 100 x 100 pixels and is located at (10,10), then the rectangle would look like this:</span>
			<span class="comment">// rect.X = 10;</span>
			<span class="comment">// rect.Y = 10;</span>
			<span class="comment">// rect.Width = 110;</span>
			<span class="comment">// rect.Height = 110;</span>
			<span class="comment">// We simply have to subtract the rect.X value from the rect.Width value to obtain the "real" width of</span>
			<span class="comment">// the window, similarly we have to subtract the Y value from the Height value to obtain the real height.</span>
			<span class="comment">// After this we have the real window properties through the X, Y, Width and Height values.</span>
			rect.Width = rect.Width - rect.X;
			rect.Height = rect.Height - rect.Y;

			<span class="comment">// Lets print the rectangle after we've fixed it so we can confirm it's correct.</span>
			Console.WriteLine(rect.ToString());

			<span class="comment">// As used earlier, we print the basic properties of the window.</span>
			printWindowInfo(handle);

			<span class="keyword">return</span> <span class="keyword">true</span>;
		}

		<span class="comment">// Prints basic properties of a window, uses function already used in previous blogs.</span>
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printWindowInfo</span>(<span class="keyword">int</span> handle)
		{
			<span class="comment">// Get the class.</span>
			StringBuilder sbClass = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);
			GetClassName(handle, sbClass, sbClass.Capacity);

			<span class="comment">// Get the text.</span>
			<span class="keyword">int</span> txtLength = SendMessage(handle, WM_GETTEXTLENGTH, <span class="number">0</span>, <span class="number">0</span>);
			StringBuilder sbText = <span class="keyword">new</span> StringBuilder(txtLength + <span class="number">1</span>);
			SendMessage(handle, WM_GETTEXT, sbText.Capacity, sbText);

			<span class="comment">// Now we can write out the information we have on the window.</span>
			Console.WriteLine(<span class="string">"Handle: "</span> + handle);
			Console.WriteLine(<span class="string">"Class : "</span> + sbClass);
			Console.WriteLine(<span class="string">"Text  : "</span> + sbText);
			Console.WriteLine();
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/getting-window-location-and-size/win32_7_1_2.jpg" class="fancy"><img src="/getting-window-location-and-size/win32_7_1_2.jpg" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/getting-window-location-and-size/win32_7_2_2.jpg" class="fancy"><img src="/getting-window-location-and-size/win32_7_2_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">07</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/finding-specific-windows/" title="Finding Specific Windows Using PInvoke" rel="bookmark">Finding Specific Windows Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Last time I made an example of how to enumerate windows. This time I present to you a class that greatly simplifies the process of searching for specific windows, types of windows, windows belonging to a specific process, having a specific text. You can search for any number of these parameters at the same time, using regular expressions for all string matches to provide optimal flexibility.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System;
<span class="keyword">using</span> System.Text;
<span class="keyword">using</span> System.Text.RegularExpressions;
<span class="keyword">using</span> System.Diagnostics;

namespace Searching_for_windows
{
	class Program
	{
		<span class="comment">// Win32 constants.</span>
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXT = <span class="number">0x000D</span>;
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXTLENGTH = <span class="number">0x000E</span>;

		<span class="comment">// Win32 functions that have all been used in previous blogs.</span>
		[DllImport(<span class="string">"User32.Dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">GetClassName</span>(<span class="keyword">int</span> hWnd, StringBuilder s, <span class="keyword">int</span> nMaxCount);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">GetWindowText</span>(<span class="keyword">int</span> hWnd, StringBuilder text, <span class="keyword">int</span> count);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, StringBuilder lParam);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, <span class="keyword">int</span> lParam);

		<span class="comment">// Main entrypoint function</span>
		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			WindowFinder wf = <span class="keyword">new</span> WindowFinder();

			<span class="comment">// Find all Internet Explorer instances</span>
			wf.FindWindows(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Regex(<span class="string">"iexplore"</span>), <span class="keyword">new</span> WindowFinder.FoundWindowCallback(foundWindow));

			<span class="comment">// Find all visual studio instances</span>
			wf.FindWindows(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Regex(<span class="string">" - Microsoft Visual Studio"</span>), <span class="keyword">new</span> Regex(<span class="string">"devenv"</span>), <span class="keyword">new</span> WindowFinder.FoundWindowCallback(foundWindow));

			Console.WriteLine(<span class="string">"Done"</span>);
			Console.Read();
		}

		<span class="comment">// Gets called each time a window is found by the WindowFinder class.</span>
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">foundWindow</span>(<span class="keyword">int</span> handle)
		{
			<span class="comment">// Print the window info.</span>
			printWindowInfo(handle);

			<span class="comment">// Continue on with next window.</span>
			<span class="keyword">return</span> <span class="keyword">true</span>;
		}

		<span class="comment">// Prints basic properties of a window, uses function already used in previous blogs.</span>
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printWindowInfo</span>(<span class="keyword">int</span> handle)
		{
			<span class="comment">// Get the class.</span>
			StringBuilder sbClass = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);
			GetClassName(handle, sbClass, sbClass.Capacity);

			<span class="comment">// Get the text.</span>
			<span class="keyword">int</span> txtLength = SendMessage(handle, WM_GETTEXTLENGTH, <span class="number">0</span>, <span class="number">0</span>);
			StringBuilder sbText = <span class="keyword">new</span> StringBuilder(txtLength + <span class="number">1</span>);
			SendMessage(handle, WM_GETTEXT, sbText.Capacity, sbText);

			<span class="comment">// Now we can write out the information we have on the window.</span>
			Console.WriteLine(<span class="string">"Handle: "</span> + handle);
			Console.WriteLine(<span class="string">"Class : "</span> + sbClass);
			Console.WriteLine(<span class="string">"Text  : "</span> + sbText);
			Console.WriteLine();
		}
	}

	<span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span>
	<span class="comment"><span class="xmlDocTag">///</span> A class used for finding windows based upon their class, title, process and parent window handle.</span>
	<span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span>
	<span class="keyword">public</span> <span class="keyword">class</span> WindowFinder
	{
		<span class="comment">// Win32 constants.</span>
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXT = <span class="number">0x000D</span>;
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXTLENGTH = <span class="number">0x000E</span>;

		<span class="comment">// Win32 functions that have all been used in previous blogs.</span>
		[DllImport(<span class="string">"User32.Dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">GetClassName</span>(<span class="keyword">int</span> hWnd, StringBuilder s, <span class="keyword">int</span> nMaxCount);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">GetWindowText</span>(<span class="keyword">int</span> hWnd, StringBuilder text, <span class="keyword">int</span> count);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, StringBuilder lParam);

		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, <span class="keyword">int</span> lParam);

		[DllImport(<span class="string">"user32"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">GetWindowThreadProcessId</span>(<span class="keyword">int</span> hWnd, <span class="keyword">out</span> <span class="keyword">int</span> lpdwProcessId);

		<span class="comment">// EnumChildWindows works just like EnumWindows, except we can provide a parameter that specifies the parent</span>
		<span class="comment">// window handle. If this is NULL or zero, it works just like EnumWindows. Otherwise it'll only return windows</span>
		<span class="comment">// whose parent window handle matches the hWndParent parameter.</span>
		[DllImport(<span class="string">"user32.Dll"</span>)]
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> Boolean <span class="title">EnumChildWindows</span>(<span class="keyword">int</span> hWndParent, PChildCallBack lpEnumFunc, <span class="keyword">int</span> lParam);

		<span class="comment">// The PChildCallBack delegate that we used with EnumWindows.</span>
		<span class="keyword">private</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">PChildCallBack</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> lParam);

		<span class="comment">// This is an event that is run each time a window was found that matches the search criterias. The boolean</span>
		<span class="comment">// return value of the delegate matches the functionality of the PChildCallBack delegate function.</span>
		<span class="keyword">private</span> <span class="keyword">event</span> FoundWindowCallback foundWindow;
		<span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">FoundWindowCallback</span>(<span class="keyword">int</span> hWnd);

		<span class="comment">// Members that'll hold the search criterias while searching.</span>
		<span class="keyword">private</span> <span class="keyword">int</span> parentHandle;
		<span class="keyword">private</span> Regex className;
		<span class="keyword">private</span> Regex windowText;
		<span class="keyword">private</span> Regex process;

		<span class="comment">// The main search function of the WindowFinder class. The parentHandle parameter is optional, taking in a zero if omitted.</span>
		<span class="comment">// The className can be null as well, in this case the class name will not be searched. For the window text we can input</span>
		<span class="comment">// a Regex object that will be matched to the window text, unless it's null. The process parameter can be null as well,</span>
		<span class="comment">// otherwise it'll match on the process name (Internet Explorer = "iexplore"). Finally we take the FoundWindowCallback</span>
		<span class="comment">// function that'll be called each time a suitable window has been found.</span>
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindWindows</span>(<span class="keyword">int</span> parentHandle, Regex className, Regex windowText, Regex process, FoundWindowCallback fwc)
		{
			<span class="keyword">this</span>.parentHandle = parentHandle;
			<span class="keyword">this</span>.className = className;
			<span class="keyword">this</span>.windowText = windowText;
			<span class="keyword">this</span>.process = process;

			<span class="comment">// Add the FounWindowCallback to the foundWindow event.</span>
			foundWindow = fwc;

			<span class="comment">// Invoke the EnumChildWindows function.</span>
			EnumChildWindows(parentHandle, <span class="keyword">new</span> PChildCallBack(enumChildWindowsCallback), <span class="number">0</span>);
		}

		<span class="comment">// This function gets called each time a window is found by the EnumChildWindows function. The foun windows here</span>
		<span class="comment">// are NOT the final found windows as the only filtering done by EnumChildWindows is on the parent window handle.</span>
		<span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">enumChildWindowsCallback</span>(<span class="keyword">int</span> handle, <span class="keyword">int</span> lParam)
		{
			<span class="comment">// If a class name was provided, check to see if it matches the window.</span>
			<span class="keyword">if</span> (className != <span class="keyword">null</span>)
			{
				StringBuilder sbClass = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);
				GetClassName(handle, sbClass, sbClass.Capacity);

				<span class="comment">// If it does not match, return true so we can continue on with the next window.</span>
				<span class="keyword">if</span> (!className.IsMatch(sbClass.ToString()))
					<span class="keyword">return</span> <span class="keyword">true</span>;
			}

			<span class="comment">// If a window text was provided, check to see if it matches the window.</span>
			<span class="keyword">if</span> (windowText != <span class="keyword">null</span>)
			{
				<span class="keyword">int</span> txtLength = SendMessage(handle, WM_GETTEXTLENGTH, <span class="number">0</span>, <span class="number">0</span>);
				StringBuilder sbText = <span class="keyword">new</span> StringBuilder(txtLength + <span class="number">1</span>);
				SendMessage(handle, WM_GETTEXT, sbText.Capacity, sbText);

				<span class="comment">// If it does not match, return true so we can continue on with the next window.</span>
				<span class="keyword">if</span> (!windowText.IsMatch(sbText.ToString()))
					<span class="keyword">return</span> <span class="keyword">true</span>;
			}

			<span class="comment">// If a process name was provided, check to see if it matches the window.</span>
			<span class="keyword">if</span> (process != <span class="keyword">null</span>)
			{
				<span class="keyword">int</span> processID;
				GetWindowThreadProcessId(handle, <span class="keyword">out</span> processID);

				<span class="comment">// Now that we have the process ID, we can use the built in .NET function to obtain a process object.</span>
				Process p = Process.GetProcessById(processID);

				<span class="comment">// If it does not match, return true so we can continue on with the next window.</span>
				<span class="keyword">if</span> (!process.IsMatch(p.ProcessName))
					<span class="keyword">return</span> <span class="keyword">true</span>;
			}

			<span class="comment">// If we get to this point, the window is a match. Now invoke the foundWindow event and based upon</span>
			<span class="comment">// the return value, whether we should continue to search for windows.</span>
			<span class="keyword">return</span> foundWindow(handle);
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/finding-specific-windows/win32_6_1_2.jpg" class="fancy"><img src="/finding-specific-windows/win32_6_1_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Apr</span>
			<span class="day">06</span>
		</div>
		<div class="lower">2007</div>
	</div>

	<div class="title">
		<h1><a href="/enumerating-windows/" title="Enumerating Windows Using PInvoke" rel="bookmark">Enumerating Windows Using PInvoke</a></h1>
		<div class="categories">
			
				<a href="/category/.NET/">.NET</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Until now we’ve seen how to retrieve basic properties of windows as well as how to interact with them by sending keypresses. Up until now we’ve had to find the handle by using Winspector or a similar program. This time I’ll present a way of finding the handles programmatically.</p>
<a id="more"></a>


<figure class="highlight cs"><pre><span class="keyword">using</span> System.Runtime.InteropServices;
<span class="keyword">using</span> System.Text;
<span class="keyword">using</span> System;

namespace Enumerating_windows
{
	class Program
	{
		<span class="comment">// These are two Win32 constants that we'll need, they were explained in an earlier blog.</span>
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXT		= <span class="number">0x000D</span>;
		<span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXTLENGTH	= <span class="number">0x000E</span>;

		<span class="comment">// SendMessage overload.</span>
		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, <span class="keyword">int</span> lParam);

		<span class="comment">// SendMessage overload.</span>
		[DllImport(<span class="string">"User32.dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> Int32 <span class="title">SendMessage</span>(<span class="keyword">int</span> hWnd, <span class="keyword">int</span> Msg, <span class="keyword">int</span> wParam, StringBuilder lParam);

		<span class="comment">// The GetClassName function takes a handle as a parameter as well as a StringBuilder</span>
		<span class="comment">// and the max capacity of the StringBuilder as parameters. It'll return the windows</span>
		<span class="comment">// class name by filling up the StringBuilder - though not any longer than the max capacity.</span>
		<span class="comment">// If the class is longer than the max capacity it will simply be cropped. Having a larger</span>
		<span class="comment">// capacity than necessary is simply a matter of performance.</span>
		[DllImport(<span class="string">"User32.Dll"</span>)]
		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">GetClassName</span>(<span class="keyword">int</span> hWnd, StringBuilder s, <span class="keyword">int</span> nMaxCount);

		<span class="comment">// The EnumWindows function will enumerate all windows in the system. Each window will cause</span>
		<span class="comment">// the PCallBack callback function to be called.</span>
		[DllImport(<span class="string">"user32.Dll"</span>)]
		<span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> EnumWindows(PCallBack callback, <span class="keyword">int</span> lParam);

		<span class="comment">// This is the delegate that sets the signature for the callback function of the EnumWindows function.</span>
		<span class="keyword">private</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">PCallBack</span>(<span class="keyword">int</span> hwnd, <span class="keyword">int</span> lParam);

		<span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
		{
			<span class="comment">// All we'll do is to invoke the EnumWindows function, passing in a new delegate specifying the EnumWindowsCallback</span>
			<span class="comment">// function as the callback function. The lParam parameter can be used to send in an integer that will be passed</span>
			<span class="comment">// onto the callback function unmodified. It's optional, but it may be useful in some situations.</span>
			EnumWindows(<span class="keyword">new</span> PCallBack(EnumWindowsCallback), <span class="number">0</span>);

			Console.Read();
		}

		<span class="comment">// This function will be called exactly once for each window the EnumWindows function finds. We have no idea what</span>
		<span class="comment">// window / type of windows it'll get called for, so we'll have to identify the windows somehow. The lParam</span>
		<span class="comment">// parameter contains the value we passed when we called the EnumWindows function.</span>
		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">EnumWindowsCallback</span>(<span class="keyword">int</span> handle, <span class="keyword">int</span> lParam)
		{
			<span class="comment">// First we'll find the class of the window as that is usually the parameter that narrows our search down the furthest.</span>
			<span class="comment">// As classes are usually rather short, a capacity of 256 ought to be plenty.</span>
			StringBuilder sbClass = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);
			GetClassName(handle, sbClass, sbClass.Capacity);

			<span class="comment">// As explained in an earlier blog we then get the text of the window.</span>
			<span class="keyword">int</span> txtLength = SendMessage(handle, WM_GETTEXTLENGTH, <span class="number">0</span>, <span class="number">0</span>);
			StringBuilder sbText = <span class="keyword">new</span> StringBuilder(txtLength + <span class="number">1</span>);
			SendMessage(handle, WM_GETTEXT, sbText.Capacity, sbText);

			<span class="comment">// Now we can write out the information we have on the window:</span>
			Console.WriteLine(<span class="string">"Handle: "</span> + handle);
			Console.WriteLine(<span class="string">"Class : "</span> + sbClass);
			Console.WriteLine(<span class="string">"Text  : "</span> + sbText);
			Console.WriteLine();

			<span class="comment">// When we return true, the EnumWindows function will proceed to call the callback function with the next window.</span>
			<span class="comment">// If we returned false, the EnumWindows function would stop and the callback function wouldn't get called again.</span>
			<span class="comment">// This can be useful if we're looking for a specific window - once it's found we can just return false, no reason</span>
			<span class="comment">// to handle any other windows.</span>
			<span class="keyword">return</span> <span class="keyword">true</span>;
		}
	}
}
</pre></figure>

<p>And the result:</p>
<div class="imgwrapper" style=""><div><a href="/enumerating-windows/win32_5_1_2.jpg" class="fancy"><img src="/enumerating-windows/win32_5_1_2.jpg" style="max-height: 250px"/></a></div></div>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>


<div class="paging">
	<a href="/page/20/"><div class="past">« Past</div></a>
	<a href="/page/18/"><div class="future">Future »</div></a>
	<div class="clear"></div>
</div>

				</div>
			</div>

			<div id="asides">
				<div class="categories aside">
					<span class="sectiontitle">CATEGORIES</span>
					<ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/category/.NET/">.NET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/AS/Flex/Flash/">AS/Flex/Flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Amazon Web Services/">Amazon Web Services</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Computer Science/">Computer Science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Conferences and Presenting/">Conferences and Presenting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/IIS/">IIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Miscellaneous/">Miscellaneous</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Performance/">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Poker/">Poker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server/">SQL Server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Community/">SQL Server - Community</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Data Types/">SQL Server - Data Types</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Internals/">SQL Server - Internals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Optimization/">SQL Server - Optimization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - OrcaMDF/">SQL Server - OrcaMDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Tricks/">SQL Server - Tricks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Testing/">Testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Tools of the Trade/">Tools of the Trade</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Umbraco/">Umbraco</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Visual Studio/">Visual Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Windbg/">Windbg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Windows/">Windows</a></li></ul>

					
				</div>

				<div class="archive aside">
					<span class="sectiontitle">ARCHIVE</span>
					<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archive/2014">2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2013">2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2012">2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2011">2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2010">2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2009">2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2008">2008</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2007">2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2006">2006</a></li></ul>
				</div>
			</div>

			<div class="clear"></div>
		</div>
		
		<footer>
			<div class="wrapper">Copyright &copy; 2014 Mark S. Rasmussen</div>
		</footer>

		<script type="text/javascript">
			$(function () {
				// Show mobile menu
				$("li.navicon").click(function () {
					if ($("header ul.mobile a").length == 0) {
						// Pages
						$mobilePages = $("div#naviconcontent ul.pages");
						$("header nav ul.normal > li").not(".navicon").each(function (i, el) {
							$mobilePages.append($(el).clone());
						});

						// Categories
						$mobileCategories = $("div#naviconcontent ul.categories");
						$("div#asides div.categories > ul > li").each(function (i, el) {
							$mobileCategories.append($(el).clone());
						});

						// Archive
						$mobileArchive = $("div#naviconcontent ul.archive");
						$("div#asides div.archive > ul > li").each(function (i, el) {
							$mobileArchive.append($(el).clone());
						});
					};

					$("header ul.mobile").toggle();
				});

				// Fancybox setup
				$("a.fancy").fancybox({
					hideOnContentClick: true,
					overlayShow: true
				});
			});
		</script>
	</body>
</html>