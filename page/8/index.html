<!DOCTYPE html>
<html>
	

<head>
	<title>Mark S. Rasmussen</title>
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
	<meta charset="UTF-8" />
	<meta property="og:locale" content="en_US" />
	<meta property="og:type" content="website" />
	<meta name="google-site-verification" content="alt7-wfK3ZujMQ4D0jYNd0yC5LGetGdqBlBmZsqQlVw" />
	<meta content="article" property="og:type">
<meta content="Mark S. Rasmussen" property="og:title">
<meta content="http://improve.dk/page/8/" property="og:url">
<meta property="og:image">
<meta content="Mark S. Rasmussen" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
	<link rel="alternative" href="http://feeds.feedburner.com/Improvedk" title="Mark S. Rasmussen" type="application/atom+xml">
	<script src="/js/combined.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-2479580-1', 'improve.dk');
		ga('require', 'displayfeatures');
		ga('send', 	'pageview');
	</script>
	<link rel="stylesheet" href="/css/style.css" type="text/css" />
</head>
	<body>
		<div id="headerline"></div>
	
		<header>
			<div class="wrapper">
				<div id="title">
					<a href="/">Mark S. Rasmussen</a> <span>improve.dk</span>
				</div>
				
				<nav>
					<ul class="normal">
						<li class="navicon"></li>
						<li><a href="/about-me/">About Me</a></li>
					</ul>
				</nav>
				
				<ul id="sharing">
					<li><a href="mailto:mark@improve.dk" id="shareat"></a></li>
					<li><a href="http://feeds.feedburner.com/Improvedk" id="rssfeed"></a></li>
					<li><a href="https://twitter.com/improvedk" id="sharetwitter"></a></li>
					<li><a href="https://github.com/improvedk" id="sharegithub"></a></li>
					<li><a href="https://www.linkedin.com/in/markrasmussen/" id="sharelinkedin"></a></li>
				</ul>

				<div class="clear"></div>
				
				<div id="naviconcontent">
					<ul class="mobile">
						<li>
							Pages
							<ul class="pages"></ul>
						</li>
						<li>
							Categories
							<ul class="categories"></ul>
						</li>
						<li>
							Archive
							<ul class="archive"></ul>
						</li>
					</ul>
				</div>
			</div>
		</header>

		<div id="mainwrapper">
			<div id="contentwrapper">
				<div id="content">
				
					
	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Aug</span>
			<span class="day">03</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/sqlbits-9-agenda-published/" title="SQLBits 9 Agenda Published" rel="bookmark">SQLBits 9 Agenda Published</a></h1>
		<div class="categories">
			
				<a href="/category/Conferences and Presenting/">Conferences and Presenting</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>The <a href="http://sqlbits.com/information/Agenda.aspx" target="_blank">agenda for SQLBits 9</a> has been published (though it’s still provisional). It’s looking really, really good. Especially so when you consider the price of the event – you’ve got until the 26th of August to get the <a href="http://sqlbits.com/information/Pricing.aspx" target="_blank">early bird price</a> of £375 for two complete days of conference – PLUS a whole day of <a href="http://sqlbits.com/information/TrainingDay.aspx" target="_blank">full day training sessions</a>.</p>
<a id="more"></a>

<h2 id="My_presentation">My presentation</h2>
<p>I’ll be presenting my <a href="http://sqlbits.com/Sessions/Event9/Knowing_the_Internals_Who_Needs_SQL_Server_Anyway_" target="_blank">Knowing the Internals, Who Needs SQL Server Anyway?</a> session. This is by far my favorite session! I originally gave it back in April at Miracle Open World, though under the name “Anatomy of an MDF File”. Since then, I’ve added a good three months of development onto <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF</a>, the project on which the backend of the session is based. As such, this session will be even more awesome than last! Here’s the abstract:</p>
<blockquote>
<p>You’re stuck on a remote island with just a laptop and your main database .MDF file. The boss calls and asks you to retrieve some data, but alas, you forgot to install SQL Server on your laptop. Luckily you have a HEX editor by your side! </p>
<p>In this level 500 deep dive session we will go into the intimate details of the MDF file format. Think using DBCC Page is pushing it? Think again! As a learning experiment, I’ve created an open source parser for MDF files, called OrcaMDF. Using the OrcaMDF parser I’ll go through the primary storage structures, how to parse page headers, boot pages, internal system tables, data &amp; index records, b-tree structures as well as the supporting IAM, GAM, SGAM &amp; PFS pages. </p>
<p>Has your database suffered an unrecoverable disk corruption? This session might just be your way out! Using a corrupt &amp; unattachable MDF file, I’ll demo how to recover as much data as possible. This session is not for the faint of heart, there will be bits &amp; bytes.</p>
</blockquote>
<h2 id="My_training_day">My training day</h2>
<p>If you think the session sounds awesome, fret not, you can opt in for a full day of delicious SQL Server internals at a level few people venture to! As I just blogged about recently, <a href="/how-not-to-reinvent-indexes">knowing the internals is the key to creating efficient databases</a>, without knowing how to do so. I’m honored to have <a href="http://sqlblogcasts.com/blogs/simons/archive/2011/07/26/must-attend-training-day-for-anyone-serious-about-sql.aspx" target="_blank">Simon Sabin feature my training day on his blog</a>, and I really cannot promote it any better than he does. This is the official abstract:</p>
<blockquote>
<p>Join me for a journey into the depths of the SQL Server storage engine. Through a series of lectures and demonstrations we’ll look at the internals of pages, data types, indexes, heaps, extent &amp; page allocation, allocation units, system views, base tables and nightmarish ways of data recovery. We’ll look at several storage structures that are either completely undocumented or very scarcely so.  By the end of the day, not only will you know about the most important data structures in SQL Server, you’ll also be able to parse every bit of a SQL Server data file yourself, using just a hex editor! There will be lots of hands on demos, a few of them performed in C# to demonstrate the parsing of data files outside of SQL Server.</p>
</blockquote>
<p>For a more thorough agenda, you should <a href="http://sqlbits.com/information/Event9/SQL_Server_Storage_Engine_and_MDF_File_Internals/TrainingDetails.aspx" target="_blank">go check it out at the SQLBits website</a>.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Aug</span>
			<span class="day">01</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/how-not-to-reinvent-indexes/" title="How Not to Reinvent Indexes" rel="bookmark">How Not to Reinvent Indexes</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server/">SQL Server</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>In a moment of weakness I <a href="https://twitter.com/#!/improvedk/status/96646125402062849" target="_blank">pleged to make an absolute fool of myself</a> for this months <a href="http://thomaslarock.com/2011/07/meme-monday-for-august/" target="_blank">Meme Monday</a>. I wish I could say that this happened 20 years ago, when I was but a young grasshopper. To my disgrace, this happened fewer years ago than I’d like to admit.</p>
<a id="more"></a>

<h2 id="Wow,_that’s_a_lot_of_data!">Wow, that’s a lot of data!</h2>
<p>As part of beginning a new project that would publish catalogs on the web, I tried to do some capacity calculations on storing user statistics. We needed to be able to query the number of views a single page in a given catalog had had, by the hour. Assuming a worst case scenario of 24/7 visitors for a catalog with 100 pages, that would equal 100 pages <em> 24 hours </em> 365 days, roughly equal to a million rows per year, per catalog.</p>
<p>At this point I’d been working with SQL Server for some years, though exclusively as a developer. I had no knowledge of the inner workings, storage, index internals, etc. I knew enough to get by as a normal web dev, never really reaching any limits in SQL Server no matter how brain dead my solutions were. As a result, when I figured we might have hundreds of these catalogs, we might have hundreds of millions of rows. Wow, there’s absolutely no way SQL Server will be able to search that must data in a table!</p>
<h2 id="Reinventing_the_clustered_index">Reinventing the clustered index</h2>
<p>Being convinced there was no way SQL Server would be able to search that many rows in a single table, I chose to shard my data. Not into separate tables, that’d be too easy. Instead I opted to create a database per catalog, with the sole purpose of storing statistics.</p>
<p>This was brilliant. It really was. Or at least I thought so.</p>
<p>Now instead of SQL Server having to search through a hundred million row large table, I would just query my catalog statistics like so:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> CatalogStatistics_[CatalogID].dbo.StatisticsTable <span class="keyword">WHERE</span> Period BETWEEN @X <span class="keyword">AND</span> @Y</span>
</pre></figure>

<p>I knew indexes were crucial to querying so I made sure to create a nonclustered index on the Period column. Usually It’d go unused as it would require massive amounts of bookmark lookups and there’d be sufficiently small amounts of data that a clustered index scan was more effective.</p>
<h2 id="Knowing_of_indexes_does_not_mean_you_understand_them">Knowing of indexes does not mean you understand them</h2>
<p>Obviously I’d heard of indexes, I’d even used them actively. I thought I understood them – you just create them on the columns you query and everything works faster, right?</p>
<p>I’ll give myself the credit that I knew SQL Server would need some kind of way to quickly narrow down the data it had to search. I thought I’d help out SQL Server by storing the data in separate databases, making sure it would be easy for it to scan just the data for a specific catalog. Had I known how indexes really worked, being stored in an ordered binary tree, I’d realize SQL Server wouldn’t benefit from my scheme at all.</p>
<p>I just made stuff worse by causing log trashing, disk trashing, memory trashing, management trashing, backup trashing, you name it, I trashed it.</p>
<h2 id="Dude,_this_isn’t_gonna_work">Dude, this isn’t gonna work</h2>
<p>Fast forward a couple of months. Performance wasn’t the bottleneck as there just wasn’t nearly enough data or querying to really cause concern. What was becoming a bottleneck on the other hand; management. We were on a managed server solution with an external hosting company acting as DBAs, though only ensuring SQL Server was running and was backed up. I got an email saying that they were having trouble handling our backups. At that point we had just short of 3.000 databases on the instance.</p>
<p>At the same time I was having trouble satisfying our querying requirements. In the beginning we just needed to query the statistics of a single catalog at a time. Later on we needed to dynamically aggregate statistics across several catalogs at a time. Suffice to say, this didn’t work out well in the long run:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">SELECT</span> X, Y, Z <span class="keyword">FROM</span> CatalogStatistics_123.dbo.StatisticsTable <span class="keyword">WHERE</span> Period BETWEEN @X <span class="keyword">AND</span> @Y

<span class="keyword">UNION</span> <span class="keyword">ALL</span>

<span class="keyword">SELECT</span> X, Y, Z <span class="keyword">FROM</span> CatalogStatistics_392.dbo.StatisticsTable <span class="keyword">WHERE</span> Period BETWEEN @X <span class="keyword">AND</span> @Y

<span class="keyword">UNION</span> <span class="keyword">ALL</span>

<span class="keyword">SELECT</span> X, Y, Z <span class="keyword">FROM</span> CatalogStatistics_940.dbo.StatisticsTable <span class="keyword">WHERE</span> Period BETWEEN @X <span class="keyword">AND</span> @Y

<span class="keyword">UNION</span> <span class="keyword">ALL</span>

<span class="keyword">SELECT</span> X, Y, Z <span class="keyword">FROM</span> CatalogStatistics_1722.dbo.StatisticsTable <span class="keyword">WHERE</span> Period BETWEEN @X <span class="keyword">AND</span> @Y

...</span>
</pre></figure>

<h2 id="My_revelation">My revelation</h2>
<p>I remember going to my first SQL Server conference, attending an entry level internals session. Suddenly I knew what a page was, I knew, on a high level, how data was stored in SQL Server. Suddenly I understood the importance of the data being stored in a b-tree and how much it meant to my scalability concerns.</p>
<p>What I really like about this whole ordeal, when looking back at it, is how I didn’t attend a session on proper indexing. I didn’t attend a session about SQL Server limitations, how to store hundreds of millions of rows. Nope, I intended a session on the internals. Having just that basic knowledge of the internals suddenly provided me the necessary knowledge to figure it out myself. Maybe this is the real reason I’ve become slightly obsessed with internals ever since.</p>
<p>I don’t want a fish, I want to know how to fish.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">18</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/" title="What is the Size of the LOB Pointer for (MAX) Types Like Varchar, Varbinary, Etc?" rel="bookmark">What is the Size of the LOB Pointer for (MAX) Types Like Varchar, Varbinary, Etc?</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>LOB types like varchar(MAX), nvarchar(MAX), varbinary(MAX) and xml suffer from split personality disorder. SQL Server may store values in-row or off-row depending on the size of the value, the available space in the record and the table settings. Because of this, it’s no easy task to predict the size of the pointer left in the record itself. You might even say… It depends.</p>
<a id="more"></a>

<p>Based on <a href="http://www.sqlservercentral.com/Forums/Topic1143500-391-1.aspx" target="_blank">this post</a>, and the fact that I’m working on LOB type support for <a href="/introducing-orcamdf">OrcaMDF</a> at the moment, I decided to look into the LOB pointer storage structures.</p>
<h2 id="Setup">Setup</h2>
<p>For testing, we’ll use a very simple schema:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Lob
(
	A <span class="keyword">char</span>(<span class="number">5000</span>) <span class="keyword">NULL</span>,
	B <span class="keyword">varchar</span>(<span class="aggregate">MAX</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>
)</span>
</pre></figure>

<h2 id="The_[BLOB_Inline_Data]_for_in-row_data">The [BLOB Inline Data] for in-row data</h2>
<p>If data is small enough (“small enough” being hard to define as it depends on the free space in the page, the mood of SQL Server and probably a bunch of other undocumented factors), it will be stored in the record itself. Let’s insert a single small row:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Lob (B) <span class="keyword">VALUES</span> (<span class="string">'Test'</span>)</span>
</pre></figure>

<p>Since A takes up 5000 bytes and we only try to insert 4 bytes into B, there’s plenty of space for it to be stored in-row, taking up only the expected 4 bytes that we inserted. This behavior is just as a normal varchar(X) SLOB column would react.</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_4.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_4.png" style="max-height: 250px"/></a></div></div>

<h2 id="The_[BLOB_Inline_Root]_for_row-overflow_data">The [BLOB Inline Root] for row-overflow data</h2>
<p>Now let’s truncate the table and insert a new row, forcing SQL Server to push the data off-row as there isn’t enough space on the original record:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> LOB
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Lob (B) <span class="keyword">VALUES</span> (REPLICATE(<span class="keyword">CAST</span>(<span class="string">'a'</span> <span class="keyword">AS</span> <span class="keyword">varchar</span>(<span class="aggregate">max</span>)), <span class="number">4000</span>))</span>
</pre></figure>

<p>Since A once again takes up a fixed amount of 5000 bytes and we’re now trying to insert 4000 more bytes, we exceed the maximum capacity of 8096 bytes for the page body, causing SQL Server to push the data off-row. Running a DBCC IND confirms that SQL Server has allocated a new IAM page to track the LOB data pages:</p>
<figure class="highlight sql"><pre>DBCC IND (X, 'Lob', -1)
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_6.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_6.png" style="max-height: 250px"/></a></div></div>

<p>Extracting the record and looking at column 2 reveals that we’re now storing a 24 byte row-overflow pointer:</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_8.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_8.png" style="max-height: 250px"/></a></div></div>

<p>This pointer, once again, is exactly like a SLOB column would be stored. The (MAX) LOB variants do have one trick that SLOBs don’t have though – they can be longer than 8000 bytes. In that case, we need more than one page to store the value – and thus the off-row pointer needs to point at more than one page. The off-row pointer, at an abstract level, points to a root of pointers that then point onwards to the actual data pages (or onto another root in case we need more than two levels of page references). If the root is small enough, it’ll be stored in-row. The smallest root possible is 12 bytes – a single page reference (the extra 12 bytes is due to overhead). Each following page reference takes up an extra 12 bytes. Thus, an inline root pointing to two pages will take up 36 bytes of space, and so forth, just look at this:</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_10.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_10.png" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_12.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_12.png" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_14.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_14.png" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_16.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_16.png" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_18.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_18.png" style="max-height: 250px"/></a></div></div>

<p>Note how we go from 24 to 36, 48, 60 and finally 72 bytes for a total of 40.000 bytes of data, stored on five data pages. Once we exceed 72 bytes, SQL Server doesn’t store the whole root inline any longer, instead if points to a single new slot on another page. The (1:379) page is a text_tree page, containing references to the pages where the data is stored:</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_20.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_20.png" style="max-height: 250px"/></a></div></div>

<p>I haven’t been able to make SQL Server store inline blob roots any larger than 72 bytes so I’m guessing that’s a hard cutoff value before it’ll start referencing text_tree pages. Ignoring text_tree pages, the pointer format so far has been exactly the same as for SLOBs. So when exactly does SQL Server store a classic 16 byte LOB pointer for (MAX) LOB types?</p>
<h2 id="The_[Textpointer]_for_LOB_data">The [Textpointer] for LOB data</h2>
<p>SQL Server will <em>never</em> store a LOB pointer for the (MAX) LOB types, <em>unless</em> the <a href="http://msdn.microsoft.com/en-us/library/ms173530.aspx" target="_blank">large value types out of row</a> setting has been turned on. Let’s clear the table, set the setting, and then insert a new row like before:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> LOB
<span class="keyword">EXEC</span> sp_tableoption N<span class="string">'Lob'</span>, <span class="string">'large value types out of row'</span>, <span class="string">'ON'</span>
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Lob (B) <span class="keyword">VALUES</span> (REPLICATE(<span class="keyword">CAST</span>(<span class="string">'a'</span> <span class="keyword">AS</span> <span class="keyword">varchar</span>(<span class="aggregate">max</span>)), <span class="number">4000</span>))</span>
</pre></figure>

<p>Now just as with the inline root, SQL Server allocates an IAM page to track the LOB data pages:</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_22.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_22.png" style="max-height: 250px"/></a></div></div>

<p>But when we look at the record stored on page (1:4380), we see that it stores a Textpointer instead of an inline blob root:</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_24.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_24.png" style="max-height: 250px"/></a></div></div>

<h2 id="Mixed_pointer_types">Mixed pointer types</h2>
<p>As long as the <a href="http://msdn.microsoft.com/en-us/library/ms173530.aspx" target="_blank">large value types out of row</a> setting is off (which it is by default), the (MAX) LOB types will act exactly like a SLOB column, except for the fact that the data can be larger than 8000 bytes. Once we turn the setting on, the (MAX) LOB types start acting like classic LOB types. So does this mean that the tables will always either use inline blob roots or textpointers? No, if only it were that simple. Take a look at this sample:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TrickyLob
(
	A <span class="keyword">varchar</span>(<span class="aggregate">MAX</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>
)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> TrickyLob <span class="keyword">VALUES</span> (<span class="string">'Mark'</span>)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> TrickyLob <span class="keyword">VALUES</span> (REPLICATE(<span class="keyword">CAST</span>(<span class="string">'a'</span> <span class="keyword">AS</span> <span class="keyword">varchar</span>(<span class="aggregate">MAX</span>)), <span class="number">9000</span>))
<span class="keyword">EXEC</span> sp_tableoption N<span class="string">'TrickyLob'</span>, <span class="string">'large value types out of row'</span>, <span class="string">'ON'</span>
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> TrickyLob <span class="keyword">VALUES</span> (REPLICATE(<span class="keyword">CAST</span>(<span class="string">'a'</span> <span class="keyword">AS</span> <span class="keyword">varchar</span>(<span class="aggregate">MAX</span>)), <span class="number">4000</span>))</span>
</pre></figure>

<p>Running DBCC PAGE on the single allocated data page reveals that we now have three records using three different pointer types:</p>
<div class="imgwrapper" style=""><div><a href="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_28.png" class="fancy"><img src="/what-is-the-size-of-the-lob-pointer-for-max-types-like-varchar-varbinary-etc/image_28.png" style="max-height: 250px"/></a></div></div>

<p>Lesson: When sp_tableoption is run to set the <a href="http://msdn.microsoft.com/en-us/library/ms173530.aspx" target="_blank">large value types out of row</a> setting, it only takes effect for newly added records. A table rebuild won’t affect existing inline blob roots either, only updates to existing records will rebuild the record and convert the inline blob root to a textpointers.</p>
<h2 id="Conclusion">Conclusion</h2>
<p>Predicting the LOB pointer type &amp; size can be tricky as it depends on multiple factors. Using the above, you should be able to get a notion of what will be stored, as well as to interpret the DBCC PAGE results you might run into.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">16</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/" title="The Garbage Null Bitmap and Why You Can&#39;t Rely on It Solely" rel="bookmark">The Garbage Null Bitmap and Why You Can&#39;t Rely on It Solely</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>While adding some extra sparse column tests to the <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF</a> test suite, I discovered an bug in my parsing of records. While the problem was simple enough, it took me a while to debug. Running the test, it worked about 40% of the time while failing the remaining 60% of the time. As I hadn’t picked up on this pattern I happily fixed (or so I thought) the bug, ran my test and verified that it was working. Shortly after the test failed – without me having changed any code. After having the first few strains of hair turn grey, I noticed the pattern and subsequently fixed the bug.</p>
<a id="more"></a>

<h2 id="The_normal_bitmap">The normal bitmap</h2>
<p>Creating a table like the following results in a record with both a null bitmap and a variable length column for the <a href="/sparse-column-storage-ndash-the-sparse-vector">sparse vector</a>:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Y (A <span class="keyword">int</span> SPARSE, B <span class="keyword">int</span> <span class="keyword">NULL</span>)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Y <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">2</span>)</span>
</pre></figure>

<p>Outputting the lone record in the lone data pages yields the following:</p>
<div class="imgwrapper" style=""><div><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_2.png" class="fancy"><img src="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_2.png" style="max-height: 250px"/></a></div></div>

<p>The only thing of interest is the null bitmap. It has a value of 0, indicating that all columns are non null. The only column that actually uses the null bitmap is the <em>B</em> column. While the B column has a column index of 1, it’s represented by index 0 in the null bitmap, given that it’s the first column utilizing the null bitmap. Since the null bitmap has a value of 0x00, we know that the remaining (and unused) 7 bits all have a value of 0 – as would be expected.</p>
<h2 id="The_garbage_bitmap">The garbage bitmap</h2>
<p>Now consider another schema, akin to the previous one:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DifferingRecordFormats (A <span class="keyword">int</span> SPARSE)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> DifferingRecordFormats <span class="keyword">VALUES</span> (<span class="number">5</span>)
<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> DifferingRecordFormats <span class="keyword">ADD</span> B <span class="keyword">int</span> <span class="keyword">NULL</span>
<span class="keyword">UPDATE</span> DifferingRecordFormats <span class="keyword">SET</span> B = <span class="number">2</span></span>
</pre></figure>

<p>While ending up with the exact same table schema, values and record layout, the null bitmap differs. The following are three sample records, resulting from running the above script three times, dropping the table in between to start on a fresh:</p>
<div class="imgwrapper" style=""><div><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_41.png" class="fancy"><img src="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_41.png" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_61.png" class="fancy"><img src="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_61.png" style="max-height: 250px"/></a></div></div>

<div class="imgwrapper" style=""><div><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_81.png" class="fancy"><img src="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_81.png" style="max-height: 250px"/></a></div></div>

<p>Notice how all three records are <em>exactly</em> the same, except for the null bitmap. It’s even identical to the “The normal bitmap” record that I fixed showed, <em>except</em> for the null bitmap value. Let’s try and convert those three null bitmaps to binary:</p>
<figure class="highlight"><pre>
0x5C = 0b0101110<span class="strong">**0**</span>
0xDA = 0b1101101<span class="strong">**0**</span>
0x16 = 0b0001011<span class="strong">**0**</span>
</pre></figure>

<p>All three bitmaps hold valid values for the bit we’re interested in – the very first (rightmost) bit. The remaining bits seem to be random garbage. While this doesn’t affect parsing as we’re not touching those spare bits, I find it interesting that the bitmap behaves differently depending on how it’s added. I’m guessing there’s an internal byte in memory that’s spilling through, having only the necessary bits flipped, instead of creating a new zeroed out byte and flipping bits as necessary on the clean byte.</p>
<h2 id="Thou_shalt_not_trust_the_null_bitmap_blindly!">Thou shalt not trust the null bitmap blindly!</h2>
<p>Having garbage in the null bitmap raises some interesting questions. Usually when we add a nullable column to a schema, we don’t have to touch the data pages since we can determine the new columns data is not present in the record, hence it must be null. This is not done using the null bitmap however. Imagine this scenario:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Garbage (A <span class="keyword">int</span> sparse)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Garbage <span class="keyword">VALUES</span> (<span class="number">5</span>)
<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Garbage <span class="keyword">ADD</span> B <span class="keyword">int</span> <span class="keyword">NULL</span>
<span class="keyword">UPDATE</span> Garbage <span class="keyword">SET</span> B = <span class="number">2</span>
<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Garbage <span class="keyword">ADD</span> E <span class="keyword">varchar</span>(<span class="number">10</span>)</span>
</pre></figure>

<p>We start out as before, causing a garbage null bitmap that might have a value of 0b01011000, meaning the third three columns are non-null – that is, B and E (since A is sparse and therefor doesn’t utilize the null bitmap). But E <em>is</em> null, even though the null bitmap says otherwise. This is the record as it may (given that the null bitmap value can vary) look after the above queries have been run:</p>
<div class="imgwrapper" style=""><div><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_101.png" class="fancy"><img src="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_101.png" style="max-height: 250px"/></a></div></div>

<p>So according to the null bitmap, both B and E are null – doing a select confirms that that is not the case however:</p>
<div class="imgwrapper" style=""><div><a href="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_121.png" class="fancy"><img src="/depending-on-how-itrsquos-added-spare-bits-in-the-null/image_121.png" style="max-height: 250px"/></a></div></div>

<p>So how do we determine that E is in fact null? By ignoring the null bitmap and realizing there’s no data for E. The column count for the record has a value of 1. It’s important to note that the column count counts the total number of non-sparse columns present in the record, including variable length. Since this has a value of 1 and there’s a fixed-length column present, that’s the one it’s counting. While there’s also a variable length column, that’s the sparse vector – identified by the fact that the column count didn’t include it, and that the variable length offset array entry identifies it as a <a href="/identifying-complex-columns-in-records">complex column</a>.</p>
<h2 id="Conclusion">Conclusion</h2>
<p>I’m having <a href="/the-null-bitmap-is-not-always-present-in-data-records">some</a> <a href="/the-8-byte-record-that-was-9-bytes-while-making-no-sense">fun</a> causing all kinds of edge cases due to sparse columns, even more fun trying to reason why what’s happening is happening. I haven’t seen garbage bitmaps before working with sparse columns and causing the specific scenario where the bitmap is added to a data record that doesn’t already have one. The most important thing to realize is that it doesn’t matter, at all. When doing reads of a record, the first thing we should check is <em>not</em> the null bitmap, but whether to expect the column in the record and afterwards whether there is a null bitmap at all (it may not be present in these sparse scenarios, as well as for index records).</p>
<p>Below is a pseudo code presentation of how I’m currently parsing records, passing all current tests. Note that it’s leaving out a lot of details, but the overall logic follows the actual implementation. Also note that I’m continually updating this as I discover new edge cases that I haven’t taken into account.</p>
<figure class="highlight sql"><pre>foreach column in schema {
	if(sparse) {
		if(record has sparse vector) {
			Value = [Read value from sparse vector, possibly NULL]
		} else {
			Value = NULL
		}
	} else {
		if(non-sparse column index &lt; record.NumberOfColumns) {
			if(record does not have a null bitmap OR null bitmap indicates non NULL) {
				if(column is variable length) {
					Value = [Read value from variable length data section]
				} else {
					Value = [Read value from fixed length data section]
				}
			} else {
				Value = NULL
			}
		} else {
			Value = NULL
		}
	}
}
</pre></figure>



				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">16</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/the-8-byte-record-that-was-9-bytes-while-making-no-sense/" title="The 8 Byte Record That Was 9 Bytes While Making No Sense" rel="bookmark">The 8 Byte Record That Was 9 Bytes While Making No Sense</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Warning: this is a <em>select is (most likely) not broken, it’s just not working as I’d expect</em>. It may very well be that I’m just overlooking something, in which case I hope someone will correct me :)</p>
<a id="more"></a>

<p>I’ve previously blogged about <a href="/the-null-bitmap-is-not-always-present-in-data-records/">how sparse-column-only table records didn’t have a null bitmap</a>, nor did they store the usual column count, except for the number of variable length columns. In my effort to test <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF</a>, I added the following SQL code as the setup for a test:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ScanAllNullSparse
(
	A <span class="keyword">int</span> SPARSE,
	B <span class="keyword">int</span> SPARSE
)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> ScanAllNullSparse <span class="keyword">DEFAULT</span> <span class="keyword">VALUES</span></span>
</pre></figure>

<p>Dumping out the resulting record yields the following:</p>
<div class="imgwrapper" style=""><div><a href="/the-8-byte-record-that-was-9-bytes-while-making-no-sense/image_21.png" class="fancy"><img src="/the-8-byte-record-that-was-9-bytes-while-making-no-sense/image_21.png" style="max-height: 250px"/></a></div></div>

<p>And this is where things start to get weird. The status bits (<span style="color: #ff0000;">red</span>) are all off, meaning there’s neither a null bitmap nor variable length columns in this record. The next two (<span style="color: #0000ff;">blue</span>) bytes indicate the end offset of the fixed length portion – right after those two very bytes, since we don’t have any fixed length data.</p>
<p>At this point I’m not too sure what to expect next – after all, in the <a href="/the-null-bitmap-is-not-always-present-in-data-records/">previous blog post</a> I showed how the column count wasn’t stored in all-sparse tables. Also, the status bits indicate that there’s no null bitmap. But what is the <span style="color: #008000;">green</span> 0x0100 (decimal value 1) bytes then? The only value I can see them possible indicating is the number of variable length columns. But why would that be present when the status bits indicate there are no such columns? Oh well, if that’s the case, then the next two (<span style="color: #ff0080;">pink</span>) bytes must be the offset array entry for the variable length column – having a value of 8 indicates that the variable length column has no value.</p>
<p>But wait, if the variable length column doesn’t have a value, then what is that last (<span style="color: #d16349;">orange/brownish</span>) 0x00 byte doing at the very end? That’s beyond the offset marked in the (assumedly) variable length offset array… And if the <span style="color: #ff0080;">pink</span> bytes really is the variable length offset array – should it not indicate a complex column for the sparse vector? (though it would make sense for it not to do so, if it weren’t stored in the record).</p>
<p>I can still parse this by just taking some precautions, but I still don’t understand what’s going on. Any suggestions?</p>
<h2 id="It’s_not_just_DBCC_PAGE">It’s not just DBCC PAGE</h2>
<p>To clear DBCC PAGE of any suspicion I amended my original test by inserting two extra rows with DEFAULT VALUES. The resulting offset table looks like this:</p>
<div class="imgwrapper" style=""><div><a href="/the-8-byte-record-that-was-9-bytes-while-making-no-sense/image_42.png" class="fancy"><img src="/the-8-byte-record-that-was-9-bytes-while-making-no-sense/image_42.png" style="max-height: 250px"/></a></div></div>

<p>As can be seen, the storage engine allocates 9 bytes for all three rows (though we can only verify the first two). Thus it’s not just DBCC PAGE that reads the records as being 9 bytes, so does the storage engine. This just strengthens the case that SQL Server knows best, now if only I could figure out why :)</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">15</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/the-null-bitmap-is-not-always-present-in-data-records/" title="The Null Bitmap is Not Always Present in Data Records" rel="bookmark">The Null Bitmap is Not Always Present in Data Records</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>While <a href="/sparse-column-storage-ndash-the-sparse-vector/">implementing sparse column support</a> for <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF</a>, I ran into a special condition that caught me by surprise – a data record with no null bitmap. Even <a href="http://www.sqlskills.com/BLOGS/PAUL/" target="_blank">Paul Randal</a> mentioned that the null bitmap would <em>always</em> be present in data records in his <a href="http://www.sqlskills.com/BLOGS/PAUL/post/A-SQL-Server-DBA-myth-a-day-(630" target="_blank">A SQL Server DBA myth a day: (6/30) three null bitmap myths</a>-three-null-bitmap-myths.aspx) post.</p>
<a id="more"></a>

<h2 id="Optimized_storage_of_sparse-only_tables">Optimized storage of sparse-only tables</h2>
<p>During my testing I discovered that tables containing only sparse columns neither stored a null bitmap, nor the usual number of columns. Let’s create a test table and find a reference to the data page:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> OnlyFixedSparse (A <span class="keyword">int</span> SPARSE)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> OnlyFixedSparse <span class="keyword">VALUES</span> (<span class="number">5</span>)
DBCC IND (X, <span class="string">'OnlyFixedSparse'</span>, -<span class="number">1</span>)</span>
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/the-null-bitmap-is-not-always-present-in-data-records/image_211.png" class="fancy"><img src="/the-null-bitmap-is-not-always-present-in-data-records/image_211.png" style="max-height: 250px"/></a></div></div>

<p>And then let’s check the record contents for page (1:4359):</p>
<figure class="highlight sql"><pre>DBCC PAGE (X, 1, 4359, 3)
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/the-null-bitmap-is-not-always-present-in-data-records/image_65.png" class="fancy"><img src="/the-null-bitmap-is-not-always-present-in-data-records/image_65.png" style="max-height: 250px"/></a></div></div>

<p>The first two bytes contain the record status bits. Next two bytes contain the offset for the end of the fixed-length portion of the record – which is 4 as expected, since we have no non-sparse fixed-length columns. As shown in the <em>Record Attributes</em> output, the status bytes indicates that there’s no null bitmap, and sure enough, the next two bytes indicates the number of variable length columns. The remaining bytes contains the variable length offset array as well as the <a href="/sparse-column-storage-ndash-the-sparse-vector/">sparse vector</a>.</p>
<h3 id="Under_what_conditions_does_the_data_record_not_contain_a_null_bitmap?">Under what conditions does the data record not contain a null bitmap?</h3>
<p>I did a quick empirical test to verify my theory that this only happens on tables containing only sparse columns:</p>
<table width="500"><br>    <tbody><br>        <tr><br>            <td valign="top" width="299"><strong>Schema</strong></td><br>            <td valign="top" width="193"><strong>Contains null bitmap</strong></td><br>        </tr><br>        <tr><br>            <td valign="top" width="299">Only variable length columns</td><br>            <td valign="top" width="193">Yes</td><br>        </tr><br>        <tr><br>            <td valign="top" width="299">Only fixed length columns</td><br>            <td valign="top" width="193">Yes</td><br>        </tr><br>        <tr><br>            <td valign="top" width="299">Only sparse fixed length columns</td><br>            <td valign="top" width="193">No</td><br>        </tr><br>        <tr><br>            <td valign="top" width="299">Only sparse variable length columns</td><br>            <td valign="top" width="193">No</td><br>        </tr><br>        <tr><br>            <td valign="top" width="299">Fixed length + sparse fixed length columns</td><br>            <td valign="top" width="193">Yes</td><br>        </tr><br>        <tr><br>            <td valign="top" width="299">Variable length + sparse fixed length columns</td><br>            <td valign="top" width="193">Yes</td><br>        </tr><br>    </tbody><br></table>

<p>Thus it would seem that this is an optimization made possible for tables containing nothing but sparse columns.</p>
<h3 id="There’s_always_an_exception_to_the_exception">There’s always an exception to the exception</h3>
<p>It <em>is</em> actually possible to have a data record without a null bitmap for a table with non-sparse columns too. Continuing on from the OnlyFixedSparse table from before, let’s add two extra nullable columns:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OnlyFixedSparse <span class="keyword">ADD</span> B <span class="keyword">int</span> <span class="keyword">NULL</span>
<span class="keyword">Alter</span> <span class="keyword">Table</span> OnlyFixedSparse <span class="keyword">ADD</span> C <span class="keyword">varchar</span>(<span class="number">10</span>) <span class="keyword">NULL</span></span>
</pre></figure>

<p>Checking the stored record reveals the exact same output as before:</p>
<div class="imgwrapper" style=""><div><a href="/the-null-bitmap-is-not-always-present-in-data-records/image_86.png" class="fancy"><img src="/the-null-bitmap-is-not-always-present-in-data-records/image_86.png" style="max-height: 250px"/></a></div></div>

<p>Thus it would seem that even without a null bitmap the usual alter semantics are followed – the addition of new nullable columns does not need to alter existing records. If we’d added a non-nullable column to the table, we would have to modify the record, causing the addition of a null bitmap and column count. The same goes if we insert a value into any of those new columns:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">UPDATE</span> OnlyFixedSparse <span class="keyword">SET</span> B = <span class="number">2</span></span>
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/the-null-bitmap-is-not-always-present-in-data-records/image_105.png" class="fancy"><img src="/the-null-bitmap-is-not-always-present-in-data-records/image_105.png" style="max-height: 250px"/></a></div></div>

<p>By setting the value of the B column we just added 7 extra bytes to our data record. 4 for the integer, 2 for the column count and 1 for the null bitmap. Had we not performed the update for all records in the table, only the affected records would be updated. This means we may have data records for a table where some have a null bitmap while others don’t. Just take a look at this:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> OnlyFixedSparse (A <span class="keyword">int</span> SPARSE)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> OnlyFixedSparse <span class="keyword">VALUES</span> (<span class="number">5</span>), (<span class="number">6</span>)
<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OnlyFixedSparse <span class="keyword">ADD</span> B <span class="keyword">int</span> <span class="keyword">NULL</span>
<span class="keyword">UPDATE</span> OnlyFixedSparse <span class="keyword">SET</span> B = <span class="number">2</span> <span class="keyword">WHERE</span> A = <span class="number">5</span></span>
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/the-null-bitmap-is-not-always-present-in-data-records/image_125.png" class="fancy"><img src="/the-null-bitmap-is-not-always-present-in-data-records/image_125.png" style="max-height: 250px"/></a></div></div>

<h2 id="Conclusion">Conclusion</h2>
<p>As I unfortunately do not work on the SQL Server team and I haven’t seen this condition documented, I can only theorize on this. For all normal data records, the null bitmap is always present, even if the table does not contain any null columns. While we can achieve <a href="http://www.sqlskills.com/blogs/paul/post/Inside-the-Storage-Engine-Anatomy-of-a-record.aspx" target="_blank">read optimizations</a> when columns may be null, for completely non-null tables, we still get the benefit that we can add a new nullable column to an existing schema, without having to modify the already existing records.</p>
<p>While I think it’s bit of a special use case, my theory is that this is a specific optimization made for the case where you have a table with lots of sparse columns and no non-sparse columns present. For those cases, we save at least three bytes – two for the number of columns and at least one for the null bitmap. If there are only sparse columns, we have no need for the null bitmap as the null value is defined by the value not being stored in the sparse vector.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">15</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/sparse-column-storage-ndash-the-sparse-vector/" title="Sparse Column Storage &amp; the Sparse Vector" rel="bookmark">Sparse Column Storage &amp; the Sparse Vector</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>In this post I’ll be looking at the internal storage mechanism that supports sparse columns. For an introduction to what sparse columns are and when they ought to be used, <a href="http://msdn.microsoft.com/en-us/library/cc280604.aspx" target="_blank">take a look here</a>.</p>
<a id="more"></a>

<p>Sparse columns, whether fixed or variable length, or not stored together with the normal columns in a <a href="http://www.sqlskills.com/blogs/paul/post/Inside-the-Storage-Engine-Anatomy-of-a-record.aspx" target="_blank">record</a>. Instead, they’re all stored in a hidden variable length column at the very end of the record (barring the potential 14 byte structure that may be stored when using versioning).</p>
<h2 id="Creating_and_finding_a_sparse_vector">Creating and finding a sparse vector</h2>
<p>Let’s create a sample table and insert a couple of test rows:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sparse
(
    ID <span class="keyword">int</span>,
    A <span class="keyword">int</span> SPARSE,
    B <span class="keyword">int</span> SPARSE,
    C <span class="keyword">int</span> SPARSE,
    D <span class="keyword">int</span> SPARSE,
    E <span class="keyword">int</span> SPARSE
)

<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Sparse (ID, B, E) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">1234</span>)
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> Sparse (ID, A, B) <span class="keyword">VALUES</span> (<span class="number">45</span>, <span class="number">243</span>, <span class="number">328</span>)</span>
</pre></figure>

<p>As you’d expect, a SELECT * yields the following result:</p>
<div class="imgwrapper" style=""><div><a href="/sparse-column-storage-ndash-the-sparse-vector/image_210.png" class="fancy"><img src="/sparse-column-storage-ndash-the-sparse-vector/image_210.png" style="max-height: 250px"/></a></div></div>

<p>Now let’s use DBCC IND to find the lone data pages ID, and then check out the stored record using DBCC PAGE:</p>
<figure class="highlight sql"><pre>DBCC IND (X, 'Sparse', -1)
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/sparse-column-storage-ndash-the-sparse-vector/image_44.png" class="fancy"><img src="/sparse-column-storage-ndash-the-sparse-vector/image_44.png" style="max-height: 250px"/></a></div></div>


<figure class="highlight sql"><pre>DBCC PAGE (X, 1, 4328, 3)
</pre></figure>

<p>This gives us two records, the first one looking like this:</p>
<div class="imgwrapper" style=""><div><a href="/sparse-column-storage-ndash-the-sparse-vector/image_85.png" class="fancy"><img src="/sparse-column-storage-ndash-the-sparse-vector/image_85.png" style="max-height: 250px"/></a></div></div>

<p>In a previous post I detailed how we <a href="/identifying-complex-columns-in-records/">identify complex columns like sparse vectors</a>, so I won’t go into too much detail there. The two red bytes is the single entry in the variable length offset array, with a value of 0x8023 = 32.803. Once we flip the high order bit (identifying this column as a complex column) we get an offset value of 35. Thus we know that the remaining 20 bytes in the record is our sparse vector.</p>
<h2 id="The_sparse_vector_structure">The sparse vector structure</h2>
<p>So what do those 20 bytes contain? The sparse vector structure looks like this:</p>
<table><br>    <tbody><br>        <tr><br>            <td valign="top" width="173"><strong>Name</strong></td><br>            <td valign="top" width="281"><strong>Bytes</strong></td><br>            <td valign="top" width="344"><strong>Description</strong></td><br>        </tr><br>        <tr><br>            <td valign="top" width="175">Complex column header</td><br>            <td valign="top" width="281">2</td><br>            <td valign="top" width="344">The header identifies the type of complex column that we’re dealing with. A value of 5 denotes a sparse vector.</td><br>        </tr><br>        <tr><br>            <td valign="top" width="175">Sparse column count</td><br>            <td valign="top" width="281">2</td><br>            <td valign="top" width="344">Number of sparse column values that are stored in the vector – only columns that have values are included in the vector.</td><br>        </tr><br>        <tr><br>            <td valign="top" width="176">Column ID set</td><br>            <td valign="top" width="281">2 <em> Number of sparse columns with values</td><br>            <td valign="top" width="344">Each sparse column storing a value will use two bytes to store the ID of the column (as seen in sys.columns).</td><br>        </tr><br>        <tr><br>            <td valign="top" width="176">Column offset table</td><br>            <td valign="top" width="281">2 </em> Number of sparse columns with values</td><br>            <td valign="top" width="344">Just like the record variable offset array, this stores two bytes per sparse column with a value. The value denotes the end of the actual value in the sparse vector.</td><br>        </tr><br>        <tr><br>            <td valign="top" width="176">Sparse data</td><br>            <td valign="top" width="281">Total length of all sparse column data values.</td><br>            <td valign="top" width="344"></td><br>        </tr><br>    </tbody><br></table>

<p>It’s interesting to note that unlike the normal record structure, fixed length and variable length sparse columns are stored in exactly the same way – both have an entry in the offset table, even though the fixed length values don’t differ in length.</p>
<h3 id="Looking_at_a_record">Looking at a record</h3>
<p>Going back to our record structure, I’ve colored it according to separate the different parts of the vector:</p>
<p><strong><span style="color: #ff0000;"><span style="color: #000000;">0x</span>0500</span><span style="color: #0000ff;">0200</span><span style="color: #9b00d3;">03000600</span><span style="color: #008000;">10001400</span>03000000d2040000</strong></p>
<p><em>Note that I’ve byte swapped the following byte references.</em></p>
<p>The first two bytes <strong><span style="color: #ff0000;">0x0005</span></strong> == 5 contains the complex column ID.</p>
<p>The next two bytes <strong><span style="color: #0000ff;">0x0002</span></strong> == 2 contains the number of sparse columns that are non-null, that is, they have a value stored in the sparse vector.</p>
<p>The purple part stores two bytes per column, namely the column IDs of the stored columns. <strong><span style="color: #9b00d3;">0x0003</span></strong> == 3, <span style="color: #9b00d3;"><strong>0x0006</strong></span> == 6.</p>
<p>Next up we have the green part – again storing two bytes per column, this time the offsets in the sparse vector. <strong><span style="color: #008000;">0x0010</span></strong> == 16, <strong><span style="color: #008000;">0x0014</span></strong> == 20.</p>
<p>Finally we have the values themselves. We know that the first column has an ID of 3 and it’s data ends et offset 16. Since the first 12 bytes are made up of the header, the actual values are stored in bytes 13-16: <strong>0x00000003</strong> == 3. The second value ends at offset 20, meaning it’s stored in bytes 17-20: <strong>0x000004d2</strong> == 1.234.</p>
<h3 id="Correlating_sparse_vector_values_with_sys-columns">Correlating sparse vector values with sys.columns</h3>
<p>Now that we have the values, we just need to correlate them with the columns whose value they store. Let’s select the columns in our Sparse table:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">SELECT</span>
	*
<span class="keyword">FROM</span>
	sys.columns
<span class="keyword">WHERE</span>
	object_id = OBJECT_ID(<span class="string">'Sparse'</span>)</span>
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/sparse-column-storage-ndash-the-sparse-vector/image_104.png" class="fancy"><img src="/sparse-column-storage-ndash-the-sparse-vector/image_104.png" style="max-height: 250px"/></a></div></div>

<p>And there we have it – the value 3 was stored in column_id = 3 =&gt; B. The value 1.234 was stored in column_id = 6 =&gt; E. Coincidentally, that matches up with our originally select query:</p>
<div class="imgwrapper" style=""><div><a href="/sparse-column-storage-ndash-the-sparse-vector/image_13.png" class="fancy"><img src="/sparse-column-storage-ndash-the-sparse-vector/image_13.png" style="max-height: 250px"/></a></div></div>

<p>The same procedure can be repeated for the second record, but I’m going to leave that as an exercise for the reader :)</p>
<h2 id="Writing_a_sparse_vector_parser_in_C">Writing a sparse vector parser in C</h2>
<p>Once we know the structure of the sparse vector, writing a parser in C# is surprisingly simple:</p>
<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.Linq;

namespace OrcaMDF.Core.Engine
{
	<span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span>
	<span class="comment"><span class="xmlDocTag">///</span> Parses sparse vectors as stored in records for tables containing sparse columns.</span>
	<span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span>
	<span class="keyword">public</span> <span class="keyword">class</span> SparseVectorParser
	{
		<span class="keyword">public</span> <span class="keyword">short</span> ColumnCount { <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; }
		<span class="keyword">public</span> IDictionary&lt;<span class="keyword">short</span>, <span class="keyword">byte</span>[]&gt; ColumnValues { <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; }

		<span class="keyword">public</span> <span class="title">SparseVectorParser</span>(<span class="keyword">byte</span>[] bytes)
		{
			<span class="comment">// First two bytes must have the value 5, indicating this is a sparse vector</span>
			<span class="keyword">short</span> complexColumnID = BitConverter.ToInt16(bytes, <span class="number">0</span>);
			<span class="keyword">if</span> (complexColumnID != <span class="number">5</span>)
				<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Input bytes does not contain a sparse vector."</span>);

			<span class="comment">// Number of columns contained in this sparse vector</span>
			ColumnCount = BitConverter.ToInt16(bytes, <span class="number">2</span>);

			<span class="comment">// For each column, read the data into the columnValues dictionary</span>
			ColumnValues = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">short</span>, <span class="keyword">byte</span>[]&gt;();
			<span class="keyword">short</span> columnIDSetOffset = <span class="number">4</span>;
			<span class="keyword">short</span> columnOffsetTableOffset = (<span class="keyword">short</span>)(columnIDSetOffset + <span class="number">2</span> * ColumnCount);
			<span class="keyword">short</span> columnDataOffset = (<span class="keyword">short</span>)(columnOffsetTableOffset + <span class="number">2</span> * ColumnCount);
			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ColumnCount; i++)
			{
				<span class="comment">// Read ID, data offset and data from vector</span>
				<span class="keyword">short</span> columnID = BitConverter.ToInt16(bytes, columnIDSetOffset);
				<span class="keyword">short</span> columnOffset = BitConverter.ToInt16(bytes, columnOffsetTableOffset);
				<span class="keyword">byte</span>[] data = bytes.Take(columnOffset).Skip(columnDataOffset).ToArray();

				<span class="comment">// Add ID + data to dictionary</span>
				ColumnValues.Add(columnID, data);

				<span class="comment">// Increment both ID and offset offsets by two bytes</span>
				columnIDSetOffset += <span class="number">2</span>;
				columnOffsetTableOffset += <span class="number">2</span>;
				columnDataOffset = columnOffset;
			}
		}
	}
}
</pre></figure>

<p>I won’t go into the code as it’s documented and follows the procedure we just went through. A quick test verifies that it achieves the same results as we just did by hand:</p>
<figure class="highlight cs"><pre>[TestFixture]
<span class="keyword">public</span> <span class="keyword">class</span> SparseVectorParserTests
{
	[Test]
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parse</span>()
	{
		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span> [] { <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xd2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span> };
		<span class="keyword">var</span> parser = <span class="keyword">new</span> SparseVectorParser(bytes);

		Assert.AreEqual(<span class="number">2</span>, parser.ColumnCount);
		Assert.AreEqual(<span class="number">3</span>, BitConverter.ToInt32(parser.ColumnValues[<span class="number">3</span>], <span class="number">0</span>));
		Assert.AreEqual(<span class="number">1234</span>, BitConverter.ToInt32(parser.ColumnValues[<span class="number">6</span>], <span class="number">0</span>));
	}
}
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/sparse-column-storage-ndash-the-sparse-vector/image_15.png" class="fancy"><img src="/sparse-column-storage-ndash-the-sparse-vector/image_15.png" style="max-height: 250px"/></a></div></div>

<p>You can check out the full code at the <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF Github repository</a>.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">15</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/identifying-complex-columns-in-records/" title="Identifying Complex Columns in Records" rel="bookmark">Identifying Complex Columns in Records</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p><em>For an introduction to the anatomy of records, I suggest you read </em><a href="http://www.sqlskills.com/blogs/paul/post/Inside-the-Storage-Engine-Anatomy-of-a-record.aspx" target="_blank"><em>this post</em></a><em> by </em><a href="http://www.sqlskills.com/BLOGS/PAUL/" target="_blank"><em>Paul Randal</em></a><em>.</em></p>
<a id="more"></a>

<p>Not all variable length columns are the same. Some are more… Complex than others. An example of a complex column could be the 24 byte row-overflow pointer that are used when SLOB types overflow. <a href="http://sqlblog.com/blogs/kalen_delaney/default.aspx" target="_blank">Kalen Delaney</a> has an excellent post detailing how to <a href="http://sqlblog.com/blogs/kalen_delaney/archive/2007/10/09/geek-city-detecting-overflowing-columns.aspx" target="_blank">detect overflowing columns</a>. There are more than one complex column type though, and the technique outlined in Kalen’s post can be generalized a bit further.</p>
<h2 id="Complex_columns_containing_row-overflow_pointers">Complex columns containing row-overflow pointers</h2>
<p>Technically I don’t this is a complex column as it doesn’t follow the normal format. It is however identified the same way, so I’ll treat it as a complex column in this post. Let’s create a simple table, cause one of the columns to overflow and then check the record contents:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> OverflowTest (A <span class="keyword">varchar</span>(<span class="number">8000</span>), B <span class="keyword">varchar</span>(<span class="number">8000</span>))
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> OverflowTest <span class="keyword">VALUES</span> (REPLICATE(<span class="string">'a'</span>, <span class="number">5000</span>), REPLICATE(<span class="string">'b'</span>, <span class="number">5000</span>))
DBCC IND (X, OverflowTest, -<span class="number">1</span>)</span>
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/identifying-complex-columns-in-records/image_29.png" class="fancy"><img src="/identifying-complex-columns-in-records/image_29.png" style="max-height: 250px"/></a></div></div>

<p>Outputting the contents of page (1:4345) shows the following (cropped to only show the first 36 bytes of the lone record body:</p>
<div class="imgwrapper" style=""><div><a href="/identifying-complex-columns-in-records/image_124.png" class="fancy"><img src="/identifying-complex-columns-in-records/image_124.png" style="max-height: 250px"/></a></div></div>

<p>The four colored bytes make up the variable length offset array – two bytes for each offset. The first offset has a value of 0x1395 == 5013, which fits perfectly with there being 5000 characters in the first column, plus 13 for the record overhead. The second offset has a value of 0x93AD == 37.805. Converted to binary that’s a value of 0b1001001110101101. Note how the high order bit is set to 1 – indicating a complex column. Getting the actual offset requires us to mask out the high order bit like so: 0n37805 &amp; 0b011111111111111 == 5.037. Now we can easily calculate the complex column length as being 5.037 – 5.013 == 24 bytes.</p>
<p>At this point we know that the column contains a complex column and we know that it’s 24 bytes long. Row-overflow pointers only use a single byte to identify the type of complex column – this is what distinguishes it from “normal” complex columns, hence why I’m reluctant to call it a complex column.</p>
<div class="imgwrapper" style=""><div><a href="/identifying-complex-columns-in-records/image_142.png" class="fancy"><img src="/identifying-complex-columns-in-records/image_142.png" style="max-height: 250px"/></a></div></div>

<p>The very first byte determines the type of complex column that this is. For row-overflow/LOB pointers this can either be 1, indicating a LOB pointer, or 2, indicating a row-overflow pointer. In this case the value is 2, which confirms that we’re looking at a row-overflow pointer.</p>
<h2 id="Complex_columns_containing_forwarded_record_back_pointers">Complex columns containing forwarded record back pointers</h2>
<p>I’ve previously blogged about the <a href="/anatomy-of-a-forwarded-record-ndash-the-back-pointer">anatomy of a forwarded record back pointer</a>. The important thing to note are the first two bytes in the pointer, marked with red:</p>
<div class="imgwrapper" style=""><div><a href="/identifying-complex-columns-in-records/image_163.png" class="fancy"><img src="/identifying-complex-columns-in-records/image_163.png" style="max-height: 250px"/></a></div></div>

<p>All complex columns use the first two bytes to identify the kind of complex columns. In this case a complex column ID of 1.024 indicates a back pointer.</p>
<h2 id="Complex_columns_containing_sparse_vectors">Complex columns containing sparse vectors</h2>
<p>Let’s create a simple table containing some sparse columns:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sparse
(
	ID <span class="keyword">int</span>,
	A <span class="keyword">int</span> SPARSE,
	B <span class="keyword">int</span> SPARSE,
	C <span class="keyword">int</span> SPARSE,
	D <span class="keyword">int</span> SPARSE,
	E <span class="keyword">int</span> SPARSE
)</span>
</pre></figure>

<p>Taking a look at a dump of a record looks like this:</p>
<div class="imgwrapper" style=""><div><a href="/identifying-complex-columns-in-records/image_183.png" class="fancy"><img src="/identifying-complex-columns-in-records/image_183.png" style="max-height: 250px"/></a></div></div>

<p>Note that there are no variable length columns in the table definition. However, the sparse vector is stored as a variable length field, thus we have a variable length offset array. The red bytes make up the offset array value of 0x8023 = 32.803. Flipping the high order bit yields a value of 35, indicating that all remaining bytes in the record belong to the sparse vector.</p>
<p>Since the high order bit was flipped, we know that this is a complex column. Checking out the first two bytes (marked with blue) yields a value of 0x0005. A value of 5 is exactly what indicates that we’re dealing with a sparse vector.</p>
<h2 id="Conclusion">Conclusion</h2>
<p>In general, variable length columns that contain some kind of special data will be indicated by having their high order bit flipped in the variable length offset array. While row-overflow pointers are not technically complex columns, that act similarly, except only using a single byte to indicate the column type.</p>
<p>Forwarded record back pointers are stored in complex columns having a complex column ID of 1.024.</p>
<p>Sparse vectors use a complex column ID of 5.</p>
<p>I do not know of any more complex columns as of yet, but the documentation is rather non existent except for what’s mentioned in the <a href="http://www.amazon.com/Microsoft%C2%AE-SQL-Server%C2%AE-2008-Internals/dp/0735626243" target="_blank">SQL Server 2008 Internals book</a>.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">13</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/creating-a-type-aware-parser-for-the-sys-system_internals_partition_columns-ti-field/" title="Creating a Type Aware Parser for the sys.system_internals_partition_columns.ti Field" rel="bookmark">Creating a Type Aware Parser for the sys.system_internals_partition_columns.ti Field</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Based on my findings <a href="/exploring-the-sys-system_internals_partition_columns-ti-field">exploring the sys.system_internals_partition_columns.ti field</a>, I needed parser that could extract the scale, precision, max_length as well as the max_inrow_length fields from it. The tricky part is that those values are stored differently for each individual type, added onto the fact that some types have hardcoded defaults that are not stored in the ti field, even though there’s space for it.</p>
<a id="more"></a>

<p>As a result of some reverse engineering and empirical testing, I’ve made a SysrscolTIParser class that takes in the ti value (I have no idea what the acronym stands for – type information perhaps?), determines the type and parses it corresponding to the type. I won’t go into details as that’s all described in my <a href="/exploring-the-sys-system_internals_partition_columns-ti-field">previous post</a>.</p>
<figure class="highlight cs"><pre><span class="keyword">using</span> System;
<span class="keyword">using</span> OrcaMDF.Core.MetaData.Enumerations;

namespace OrcaMDF.Core.MetaData
{
	<span class="keyword">public</span> <span class="keyword">class</span> SysrscolTIParser
	{
		<span class="keyword">public</span> <span class="keyword">byte</span> Scale;
		<span class="keyword">public</span> <span class="keyword">byte</span> Precision;
		<span class="keyword">public</span> <span class="keyword">short</span> MaxLength;
		<span class="keyword">public</span> <span class="keyword">short</span> MaxInrowLength;
		<span class="keyword">public</span> <span class="keyword">int</span> TypeID;

		<span class="keyword">public</span> <span class="title">SysrscolTIParser</span>(<span class="keyword">int</span> ti)
		{
			TypeID = ti & <span class="number">0xFF</span>;

			<span class="keyword">if</span> (!Enum.IsDefined(<span class="keyword">typeof</span>(SystemType), TypeID))
				<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Unknown TypeID '"</span> + TypeID + <span class="string">"'"</span>);

			<span class="keyword">switch</span>((SystemType)TypeID)
			{
				<span class="keyword">case</span> SystemType.Bigint:
					MaxLength = MaxInrowLength = <span class="number">8</span>;
					Precision = <span class="number">19</span>;
					<span class="keyword">break</span>;

				<span class="comment">// All CLR types internally stored as varbinaries</span>
				<span class="comment">//case SystemType.Geography:</span>
				<span class="comment">//case SystemType.Geometry:</span>
				<span class="comment">//case SystemType.Hierarchyid:</span>
				<span class="keyword">case</span> SystemType.Varbinary:
				<span class="comment">// Also covers SystemType.Sysname</span>
				<span class="keyword">case</span> SystemType.Nvarchar:
				<span class="keyword">case</span> SystemType.Binary:
				<span class="keyword">case</span> SystemType.Char:
				<span class="keyword">case</span> SystemType.Nchar:
				<span class="keyword">case</span> SystemType.Image:
				<span class="keyword">case</span> SystemType.Ntext:
				<span class="keyword">case</span> SystemType.Text:
				<span class="keyword">case</span> SystemType.Varchar:
				<span class="keyword">case</span> SystemType.Xml:
					MaxLength = (<span class="keyword">short</span>)((ti & <span class="number">0xFFFF00</span>) &gt;&gt; <span class="number">8</span>);
					<span class="keyword">if</span> (MaxLength == <span class="number">0</span>)
					{
						MaxLength = -<span class="number">1</span>;
						MaxInrowLength = <span class="number">8000</span>;
					}
					<span class="keyword">else</span>
						MaxInrowLength = MaxLength;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Bit:
					MaxLength = MaxInrowLength = Precision = <span class="number">1</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Date:
					Precision = <span class="number">10</span>;
					MaxLength = MaxInrowLength = <span class="number">3</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Datetime:
					Scale = <span class="number">3</span>;
					Precision = <span class="number">23</span>;
					MaxLength = MaxInrowLength = <span class="number">8</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Datetime2:
					Scale = (<span class="keyword">byte</span>)((ti & <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);
					Precision = (<span class="keyword">byte</span>)(<span class="number">20</span> + Scale);
					<span class="keyword">if</span> (Scale &lt; <span class="number">3</span>)
						MaxLength = MaxInrowLength = <span class="number">6</span>;
					<span class="keyword">else</span> <span class="keyword">if</span> (Scale &lt; <span class="number">5</span>)
						MaxLength = MaxInrowLength = <span class="number">7</span>;
					<span class="keyword">else</span>
						MaxLength = MaxInrowLength = <span class="number">8</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.DatetimeOffset:
					Scale = (<span class="keyword">byte</span>)((ti & <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);
					Precision = (<span class="keyword">byte</span>)(<span class="number">26</span> + (Scale &gt; <span class="number">0</span> ? Scale + <span class="number">1</span> : Scale));
					<span class="keyword">if</span> (Scale &lt; <span class="number">3</span>)
						MaxLength = MaxInrowLength = <span class="number">8</span>;
					<span class="keyword">else</span> <span class="keyword">if</span> (Scale &lt; <span class="number">5</span>)
						MaxLength = MaxInrowLength = <span class="number">9</span>;
					<span class="keyword">else</span>
						MaxLength = MaxInrowLength = <span class="number">10</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Decimal:
				<span class="keyword">case</span> SystemType.Numeric:
					Precision = (<span class="keyword">byte</span>)((ti & <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);
					Scale = (<span class="keyword">byte</span>)((ti & <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>);
					<span class="keyword">if</span> (Precision &lt; <span class="number">10</span>)
						MaxLength = MaxInrowLength = <span class="number">5</span>;
					<span class="keyword">else</span> <span class="keyword">if</span> (Precision &lt; <span class="number">20</span>)
						MaxLength = MaxInrowLength = <span class="number">9</span>;
					<span class="keyword">else</span> <span class="keyword">if</span> (Precision &lt; <span class="number">29</span>)
						MaxLength = MaxInrowLength = <span class="number">13</span>;
					<span class="keyword">else</span>
						MaxLength = MaxInrowLength = <span class="number">17</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Float:
					Precision = <span class="number">53</span>;
					MaxLength = MaxInrowLength = <span class="number">8</span>;
					<span class="keyword">break</span>;
					
				<span class="keyword">case</span> SystemType.Int:
					Precision = <span class="number">10</span>;
					MaxLength = MaxInrowLength = <span class="number">4</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Money:
					Scale = <span class="number">4</span>;
					Precision = <span class="number">19</span>;
					MaxLength = MaxInrowLength = <span class="number">8</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Real:
					Precision = <span class="number">24</span>;
					MaxLength = MaxInrowLength = <span class="number">4</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Smalldatetime:
					Precision = <span class="number">16</span>;
					MaxLength = MaxInrowLength = <span class="number">4</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Smallint:
					Precision = <span class="number">5</span>;
					MaxLength = MaxInrowLength = <span class="number">2</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Smallmoney:
					Scale = <span class="number">4</span>;
					Precision = <span class="number">10</span>;
					MaxLength = MaxInrowLength = <span class="number">4</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Sql_Variant:
					MaxLength = MaxInrowLength = <span class="number">8016</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Time:
					Scale = (<span class="keyword">byte</span>)((ti & <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);
					Precision = (<span class="keyword">byte</span>)(<span class="number">8</span> + (Scale &gt; <span class="number">0</span> ? Scale + <span class="number">1</span> : Scale));
					<span class="keyword">if</span> (Scale &lt; <span class="number">3</span>)
						MaxLength = MaxInrowLength = <span class="number">3</span>;
					<span class="keyword">else</span> <span class="keyword">if</span> (Scale &lt; <span class="number">5</span>)
						MaxLength = MaxInrowLength = <span class="number">4</span>;
					<span class="keyword">else</span>
						MaxLength = MaxInrowLength = <span class="number">5</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Timestamp:
					MaxLength = MaxInrowLength = <span class="number">8</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Tinyint:
					Precision = <span class="number">3</span>;
					MaxLength = MaxInrowLength = <span class="number">1</span>;
					<span class="keyword">break</span>;

				<span class="keyword">case</span> SystemType.Uniqueidentifier:
					MaxLength = MaxInrowLength = <span class="number">16</span>;
					<span class="keyword">break</span>;

				<span class="keyword">default</span>:
					<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"TypeID '"</span> + TypeID + <span class="string">"' not supported."</span>);
			}
		}
	}
}
</pre></figure>

<p>It uses a SystemType enumeration for switching between the types (sorry, formatting isn’t being nice to me here):</p>
<figure class="highlight cs"><pre>namespace OrcaMDF.Core.MetaData.Enumerations
{
	<span class="keyword">public</span> <span class="keyword">enum</span> SystemType
	{
		Image				= <span class="number">34</span>,
		Text				= <span class="number">35</span>,
		Uniqueidentifier		= <span class="number">36</span>,
		Date				= <span class="number">40</span>,
		Time				= <span class="number">41</span>,
		Datetime2			= <span class="number">42</span>,
		DatetimeOffset			= <span class="number">43</span>,
		Tinyint				= <span class="number">48</span>,
		Smallint			= <span class="number">52</span>,
		Int				= <span class="number">56</span>,
		Smalldatetime			= <span class="number">58</span>,
		Real				= <span class="number">59</span>,
		Money				= <span class="number">60</span>,
		Datetime			= <span class="number">61</span>,
		Float				= <span class="number">62</span>,
		Sql_Variant			= <span class="number">98</span>,
		Ntext				= <span class="number">99</span>,
		Bit				= <span class="number">104</span>,
		Decimal				= <span class="number">106</span>,
		Numeric				= <span class="number">108</span>,
		Smallmoney			= <span class="number">122</span>,
		Bigint				= <span class="number">127</span>,
		Hierarchyid			= <span class="number">240</span>,
		Geometry			= <span class="number">240</span>,
		Geography			= <span class="number">240</span>,
		Varbinary			= <span class="number">165</span>,
		Varchar				= <span class="number">167</span>,
		Binary				= <span class="number">173</span>,
		Char				= <span class="number">175</span>,
		Timestamp			= <span class="number">189</span>,
		Nvarchar			= <span class="number">231</span>,
		Nchar				= <span class="number">239</span>,
		Xml				= <span class="number">241</span>,
		Sysname				= <span class="number">231</span>
	}
}
</pre></figure>

<p>And last, but not least, a bunch of tests to verify the functionality:</p>
<figure class="highlight cs"><pre><span class="keyword">using</span> NUnit.Framework;
<span class="keyword">using</span> OrcaMDF.Core.MetaData;

namespace OrcaMDF.Core.Tests.MetaData
{
	[TestFixture]
	<span class="keyword">public</span> <span class="keyword">class</span> SysrscolTIParserTests
	{
		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bigint</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">127</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">19</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">127</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Binary</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">12973</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">50</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">173</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">50</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bit</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">104</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">1</span>, parser.Precision);
			Assert.AreEqual(<span class="number">1</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">104</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">1</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Char</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">2735</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">10</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">175</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">10</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Date</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">40</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">10</span>, parser.Precision);
			Assert.AreEqual(<span class="number">3</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">40</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">3</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Datetime</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">61</span>);
			Assert.AreEqual(<span class="number">3</span>, parser.Scale);
			Assert.AreEqual(<span class="number">23</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">61</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Datetime2</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">1834</span>);
			Assert.AreEqual(<span class="number">7</span>, parser.Scale);
			Assert.AreEqual(<span class="number">27</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">42</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">810</span>);
			Assert.AreEqual(<span class="number">3</span>, parser.Scale);
			Assert.AreEqual(<span class="number">23</span>, parser.Precision);
			Assert.AreEqual(<span class="number">7</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">42</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">7</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Datetimeoffset</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">1835</span>);
			Assert.AreEqual(<span class="number">7</span>, parser.Scale);
			Assert.AreEqual(<span class="number">34</span>, parser.Precision);
			Assert.AreEqual(<span class="number">10</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">43</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">10</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">1067</span>);
			Assert.AreEqual(<span class="number">4</span>, parser.Scale);
			Assert.AreEqual(<span class="number">31</span>, parser.Precision);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">43</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decimal</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">330858</span>);
			Assert.AreEqual(<span class="number">5</span>, parser.Scale);
			Assert.AreEqual(<span class="number">12</span>, parser.Precision);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">106</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">396138</span>);
			Assert.AreEqual(<span class="number">6</span>, parser.Scale);
			Assert.AreEqual(<span class="number">11</span>, parser.Precision);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">106</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Float</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">62</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">53</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">62</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Varbinary</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">165</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(-<span class="number">1</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">165</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8000</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">228517</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">892</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">165</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">892</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Image</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">4130</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">34</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Int</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">56</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">10</span>, parser.Precision);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">56</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Money</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">60</span>);
			Assert.AreEqual(<span class="number">4</span>, parser.Scale);
			Assert.AreEqual(<span class="number">19</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">60</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Nchar</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">5359</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">20</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">239</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">20</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ntext</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">4195</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">99</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Numeric</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">265580</span>);
			Assert.AreEqual(<span class="number">4</span>, parser.Scale);
			Assert.AreEqual(<span class="number">13</span>, parser.Precision);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">108</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">135020</span>);
			Assert.AreEqual(<span class="number">2</span>, parser.Scale);
			Assert.AreEqual(<span class="number">15</span>, parser.Precision);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">108</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">9</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Nvarchar</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">25831</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">100</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">231</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">100</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">231</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(-<span class="number">1</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">231</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8000</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Real</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">59</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">24</span>, parser.Precision);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">59</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Smalldatetime</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">58</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">16</span>, parser.Precision);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">58</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Smallint</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">52</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">5</span>, parser.Precision);
			Assert.AreEqual(<span class="number">2</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">52</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">2</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Smallmoney</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">122</span>);
			Assert.AreEqual(<span class="number">4</span>, parser.Scale);
			Assert.AreEqual(<span class="number">10</span>, parser.Precision);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">122</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sql_Variant</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">98</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8016</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">98</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8016</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Text</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">4131</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">35</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Time</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">1833</span>);
			Assert.AreEqual(<span class="number">7</span>, parser.Scale);
			Assert.AreEqual(<span class="number">16</span>, parser.Precision);
			Assert.AreEqual(<span class="number">5</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">41</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">5</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">1065</span>);
			Assert.AreEqual(<span class="number">4</span>, parser.Scale);
			Assert.AreEqual(<span class="number">13</span>, parser.Precision);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">41</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">4</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Timestamp</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">189</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">189</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tinyint</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">48</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">3</span>, parser.Precision);
			Assert.AreEqual(<span class="number">1</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">48</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">1</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Uniqueidentifier</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">36</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">36</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">16</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Varchar</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">12967</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(<span class="number">50</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">167</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">50</span>, parser.MaxInrowLength);

			parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">167</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(-<span class="number">1</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">167</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8000</span>, parser.MaxInrowLength);
		}

		[Test]
		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Xml</span>()
		{
			<span class="keyword">var</span> parser = <span class="keyword">new</span> SysrscolTIParser(<span class="number">241</span>);
			Assert.AreEqual(<span class="number">0</span>, parser.Scale);
			Assert.AreEqual(<span class="number">0</span>, parser.Precision);
			Assert.AreEqual(-<span class="number">1</span>, parser.MaxLength);
			Assert.AreEqual(<span class="number">241</span>, parser.TypeID);
			Assert.AreEqual(<span class="number">8000</span>, parser.MaxInrowLength);
		}
	}
}
</pre></figure>

<p>All of this is just one big giant bit of infrastructure I needed to implement to get my scanning of nonclustered indexes working. As soon as I’ve got that up and running, all of this, plus a lot more, will be committed &amp; pushed to the <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF repo</a>.</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>

	<article>
	<div class="datebox">
		<div class="upper">
			<span class="month">Jul</span>
			<span class="day">13</span>
		</div>
		<div class="lower">2011</div>
	</div>

	<div class="title">
		<h1><a href="/exploring-the-sys-system_internals_partition_columns-ti-field/" title="Exploring the sys.system_internals_partition_columns.ti Field" rel="bookmark">Exploring the sys.system_internals_partition_columns.ti Field</a></h1>
		<div class="categories">
			
				<a href="/category/SQL Server - Internals/">SQL Server - Internals</a>
				
			
		</div>
		
		<div class="clear"></div>
	</div>

	<div id="bodywrapper" >

		
		
			<div class="body">
			
				<p>Running sp_helptext on the sys.system_internals_partition_columns system view reveals the following internal query:</p>
<a id="more"></a>


<figure class="highlight sql"><pre><span class="operator"><span class="keyword">SELECT</span>
	c.rsid <span class="keyword">AS</span> partition_id,  
	c.rscolid <span class="keyword">AS</span> partition_column_id,  
	c.rcmodified <span class="keyword">AS</span> modified_count,  
	<span class="keyword">CASE</span> c.maxinrowlen
		<span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> p.length  
		<span class="keyword">ELSE</span> c.maxinrowlen
	<span class="keyword">END</span> <span class="keyword">AS</span> max_inrow_length,
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">1</span>) <span class="keyword">AS</span> is_replicated,    --RSC_REPLICATED  
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">4</span>) <span class="keyword">AS</span> is_logged_for_replication, --RSC_LOG_FOR_REPL  
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">2</span>) <span class="keyword">AS</span> is_dropped,    --RSC_DROPPED  
	p.xtype <span class="keyword">AS</span> system_type_id,  
	p.length <span class="keyword">AS</span> max_length,  
	p.prec <span class="keyword">AS</span> <span class="keyword">PRECISION</span>,  
	p.scale <span class="keyword">AS</span> scale,  
	CONVERT(sysname, CollationPropertyFromId(c.cid, <span class="string">'name'</span>)) <span class="keyword">AS</span> collation_name,  
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">32</span>) <span class="keyword">AS</span> is_filestream,   --RSC_FILESTREAM  
	c.ordkey <span class="keyword">AS</span> key_ordinal,  
	CONVERT(<span class="keyword">BIT</span>, <span class="number">1</span> - (c.status & <span class="number">128</span>)/<span class="number">128</span>) <span class="keyword">AS</span> is_nullable,  -- RSC_NOTNULL    
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">8</span>) <span class="keyword">AS</span> is_descending_key,  --RSC_DESC_KEY  
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">16</span>) <span class="keyword">AS</span> is_uniqueifier,   --RSC_UNIQUIFIER  
	CONVERT(<span class="keyword">SMALLINT</span>, CONVERT(BINARY(<span class="number">2</span>), c.offset & <span class="number">0xffff</span>)) <span class="keyword">AS</span> leaf_offset,  
	CONVERT(<span class="keyword">SMALLINT</span>, SUBSTRING(CONVERT(BINARY(<span class="number">4</span>), c.offset), <span class="number">1</span>, <span class="number">2</span>)) <span class="keyword">AS</span> internal_offset,  
	CONVERT(TINYINT, c.bitpos & <span class="number">0xff</span>) <span class="keyword">AS</span> leaf_bit_position,  
	CONVERT(TINYINT, c.bitpos/<span class="number">0x100</span>) <span class="keyword">AS</span> internal_bit_position,  
	CONVERT(<span class="keyword">SMALLINT</span>, CONVERT(BINARY(<span class="number">2</span>), c.nullbit & <span class="number">0xffff</span>)) <span class="keyword">AS</span> leaf_null_bit,  
	CONVERT(<span class="keyword">SMALLINT</span>, SUBSTRING(CONVERT(BINARY(<span class="number">4</span>), c.nullbit), <span class="number">1</span>, <span class="number">2</span>)) <span class="keyword">AS</span> internal_null_bit,  
	CONVERT(<span class="keyword">BIT</span>, c.status & <span class="number">64</span>) <span class="keyword">AS</span> is_anti_matter,   --RSC_ANTIMATTER  
	CONVERT(UNIQUEIDENTIFIER, c.colguid) <span class="keyword">AS</span> partition_column_guid,  
	sysconv(<span class="keyword">BIT</span>, c.status & <span class="number">0x00000100</span>) <span class="keyword">AS</span> is_sparse --RSC_SPARSE  
<span class="keyword">FROM</span>
	sys.sysrscols c
<span class="keyword">OUTER</span> APPLY
	OPENROWSET(<span class="keyword">TABLE</span> RSCPROP, c.ti) p</span>
</pre></figure>

<p>Nothing too out of the ordinary if you’ve looked at other internal queries. There’s a lot of bitmasking / shifting going on to extract multiple values from the same internal base table fields. One thing that is somewhat convoluted is the OPENROWSET(TABLE RSCPROP, c.ti) p OUTER APPLY being made.</p>
<p>A Google query for “sql server +rscprop” yields absolutely zilch results:</p>
<div class="imgwrapper" style=""><div><a href="/exploring-the-sys-system_internals_partition_columns-ti-field/image_27.png" class="fancy"><img src="/exploring-the-sys-system_internals_partition_columns-ti-field/image_27.png" style="max-height: 250px"/></a></div></div>

<p>Simplifying the query to only show the fields using the fields referring the OPENROWSET (p) results, shows that the scale, precision, max_length, system_type_id and max_inrow_length are either extracted from the ti field value directly or indirectly:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">SELECT</span>
	<span class="keyword">CASE</span> c.maxinrowlen
		<span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> p.length  
		<span class="keyword">ELSE</span> c.maxinrowlen
	<span class="keyword">END</span> <span class="keyword">AS</span> max_inrow_length,
	p.xtype <span class="keyword">AS</span> system_type_id,  
	p.length <span class="keyword">AS</span> max_length,  
	p.prec <span class="keyword">AS</span> <span class="keyword">PRECISION</span>,  
	p.scale <span class="keyword">AS</span> scale,
<span class="keyword">FROM</span>
	sys.sysrscols c
<span class="keyword">OUTER</span> APPLY
	OPENROWSET(<span class="keyword">TABLE</span> RSCPROP, c.ti) p</span>
</pre></figure>

<p>To help me identifying the ti field structure, I’ve made a test table using a number of different column types:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TITest
(
	A binary(<span class="number">50</span>),
	B <span class="keyword">char</span>(<span class="number">10</span>),
	C datetime2(<span class="number">5</span>),
	D <span class="keyword">decimal</span>(<span class="number">12</span>, <span class="number">5</span>),
	E <span class="keyword">float</span>,
	F <span class="keyword">int</span>,
	G <span class="keyword">numeric</span>(<span class="number">11</span>, <span class="number">4</span>),
	H nvarchar(<span class="number">50</span>),
	I nvarchar(<span class="aggregate">max</span>),
	J <span class="keyword">time</span>(<span class="number">3</span>),
	K tinyint,
	L varbinary(<span class="aggregate">max</span>),
	M <span class="keyword">varchar</span>(<span class="number">75</span>),
	N text
)</span>
</pre></figure>

<p>I’m not going to insert any data as that’s irrelevant for this purpose. For this next part, make sure you’re connected to the SQL Server using the <a href="http://msdn.microsoft.com/en-us/library/ms178068.aspx" target="_blank">Dedicated Administrator Connection</a>. Now let’s query the sysrscols base table to see what values are stored in the ti field for the sample fields we’ve just created:</p>
<figure class="highlight sql"><pre><span class="comment">-- Get object id of TITest table</span>
<span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.sysschobjs <span class="keyword">WHERE</span> name = <span class="string">'TITest'</span>

-- <span class="keyword">Get</span> rowset id <span class="keyword">for</span> TITest
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.sysrowsets <span class="keyword">WHERE</span> idmajor = <span class="number">213575799</span>

-- <span class="keyword">Get</span> <span class="keyword">all</span> columns <span class="keyword">for</span> rowset
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.sysrscols <span class="keyword">WHERE</span> rsid = <span class="number">72057594040614912</span></span>
</pre></figure>

<p>Besides the fact I’ve cut away some irrelevant columns, this is the result:</p>
<div class="imgwrapper" style=""><div><a href="/exploring-the-sys-system_internals_partition_columns-ti-field/image_64.png" class="fancy"><img src="/exploring-the-sys-system_internals_partition_columns-ti-field/image_64.png" style="max-height: 250px"/></a></div></div>

<p>Note how we first get the object ID by querying sysschobjs, then the partition ID by querying sysrowsets and finally the partition columns by querying sysrscols. The marked ti column are the values from which we shall extract the scale, precision, max_length, system_type_id and max_inrow_length values.</p>
<p>The following query will give a better row-by-row comparison between the ti value and the expected end result field values:</p>
<figure class="highlight sql"><pre><span class="operator"><span class="keyword">SELECT</span>
	t.name,
	r.ti,
	p.scale,
	p.<span class="keyword">precision</span>,
	p.max_length,
	p.system_type_id,
	p.max_inrow_length
<span class="keyword">FROM</span>
	sys.system_internals_partition_columns p
<span class="keyword">INNER</span> <span class="keyword">JOIN</span>
	sys.sysrscols r <span class="keyword">ON</span>
		r.rscolid = p.partition_column_id <span class="keyword">AND</span>
		r.rsid = p.partition_id
<span class="keyword">INNER</span> <span class="keyword">JOIN</span>
	sys.types t <span class="keyword">ON</span>
		t.system_type_id = p.system_type_id <span class="keyword">AND</span>
		t.user_type_id = p.system_type_id
<span class="keyword">WHERE</span>
	partition_id = <span class="number">72057594040614912</span></span>
</pre></figure>

<div class="imgwrapper" style=""><div><a href="/exploring-the-sys-system_internals_partition_columns-ti-field/image_103.png" class="fancy"><img src="/exploring-the-sys-system_internals_partition_columns-ti-field/image_103.png" style="max-height: 250px"/></a></div></div>

<h3 id="binary">binary</h3>
<p>Converting the first system_type_id into hex yields 0n173 = 0xAD. Converting the ti value yields 0n12973 = 0x32AD. An empirical test for all columns shows this to be true for them all. Thus we can conclude that the first byte (printed as the rightmost due to <a href="http://en.wikipedia.org/wiki/Endianness" target="_blank">little endianness</a>) stores the type. Extracting the value requires a simple bitmask operation:</p>
<figure class="highlight cs"><pre><span class="number">12973</span> & <span class="number">0x000000FF</span> == <span class="number">173</span>
</pre></figure>

<p>As for the length, the second byte stores the value 0x32 = 0n50. As the length is a smallint (we know it can be up to 8000, thus requiring at least a smallint), we can assume the next two bytes cover that. To extract that value, we’ll need a bitmask, as well as a shift operation to shift the two middlemost bytes one step to the right:</p>
<figure class="highlight cs"><pre>(<span class="number">12973</span> & <span class="number">0x00FFFF00</span>) &gt;&gt; <span class="number">8</span> == <span class="number">50</span>
</pre></figure>

<h3 id="datetime2">datetime2</h3>
<p>This is the same for the char field. The datetime2 field is different as it stores the scale and precision values. 0n1322 in hex yields a value of 0x52A. 0x2A being the type (42). All that remains is the 0x5/0n5 which can only be the scale. A quick with a datetime(7) field yields the same result, though the precision is then 27. Thus I’ll conclude that for the datetime2 type, precision = 20 + scale. Extracting the scale from the second byte requires almost the same operation as before, just with a different bitmask:</p>
<figure class="highlight cs"><pre>(<span class="number">1322</span> & <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span> == <span class="number">5</span>
</pre></figure>

<h3 id="decimal">decimal</h3>
<p>Moving onto decimal, we now have both a scale and a precision to take care of. Converting 0n330858 to hex yields a value of 0x50C6A. 0x6A being the type (106). 0x0C being the precision and finally 0x5 being the scale. Note that this is different from datetime2 – now the scale is stored as the third byte and not the second!</p>
<p>Extracting the third byte as the scale requires a similar bitmask &amp; shift operation as previously:</p>
<figure class="highlight cs"><pre>(<span class="number">330858</span> & <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span> == <span class="number">5</span>
</pre></figure>

<h3 id="float">float</h3>
<p>0n62 = 0x3E =&gt; the system_type_id value of 62. Thus the only value stored for the float is the type ID, the rest are a given. The same goes for the int, tinyint and similar fixed length field types.</p>
<h3 id="numeric">numeric</h3>
<p>0n265068 = 0x40B6C. 0x6C = the type ID of 108. 0xB = the precision value of 11. 0x4 = the scale value of 4.</p>
<h3 id="nvarchar_&amp;_nvarchar(max)">nvarchar &amp; nvarchar(max)</h3>
<p>These are a bit special too. Looking at the first nvarchar(100) field we can convert 0n25832 to 0x64E7. 0xE7 being the type ID of 231. 0x64 being the length of 100, stored as a two byte smallint. This shows that the parsing of non-max (n)varchar fields is pretty much in line with the rest so far.</p>
<p>The nvarchar(max) differs in that it only stores the type ID, there’s no length. Given the lack of a length (technically the invalid length of 0 is stored), we read it as being –1, telling us that it’s a LOB/MAX field being stored with a max_length of –1 and a maximum in_row length of 8000, provided it’s not stored off-row.</p>
<p>Varbinary seems to follow the exact same format.</p>
<h3 id="time">time</h3>
<p>0n809 = 0x329. 0x29 = the type ID of 41. 0x3 being the scale of 3. As with the datetime2 field, the precision scales with the scale (pun only slightly intended) – precision = 9 + scale.</p>
<h3 id="text">text</h3>
<p>0n4131 = 0x1023. 0x23 = the type ID of 35. 0x10 being the max_length of 16. The reason the text type has a max_length of 16 is that text is a LOB type that will always be stored off row, leaving just a 16 byte pointer in the record where it’s logically stored.</p>
<h2 id="Conclusion">Conclusion</h2>
<p>The OPENROWSET(TABLE RSCPROP, x) obviously performs some dark magic. The ti field is an integer that’s used to store multiple values &amp; formats, depending on the row type. Thus, to parse this properly, a switch would have to be made. Certain types also take values for a given – the precision fields based on the scale value, float having a fixed precision of 53 etc. It shouldn’t be long before I have a commit ready for <a href="https://github.com/improvedk/OrcaMDF" target="_blank">OrcaMDF</a> that’ll contain this parsing logic :)</p>


				<div style="clear: both"></div>

				

			</div>

		

		

	</div>
</article>


<div class="paging">
	<a href="/page/9/"><div class="past">« Past</div></a>
	<a href="/page/7/"><div class="future">Future »</div></a>
	<div class="clear"></div>
</div>

				</div>
			</div>

			<div id="asides">
				<div class="categories aside">
					<span class="sectiontitle">CATEGORIES</span>
					<ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/category/.NET/">.NET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/AS/Flex/Flash/">AS/Flex/Flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Amazon Web Services/">Amazon Web Services</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Computer Science/">Computer Science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Conferences and Presenting/">Conferences and Presenting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/IIS/">IIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Misc/">Misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Miscellaneous/">Miscellaneous</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Performance/">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Poker/">Poker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server/">SQL Server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Community/">SQL Server - Community</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Data Types/">SQL Server - Data Types</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Internals/">SQL Server - Internals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Optimization/">SQL Server - Optimization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - OrcaMDF/">SQL Server - OrcaMDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/SQL Server - Tricks/">SQL Server - Tricks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Testing/">Testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Tools of the Trade/">Tools of the Trade</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Umbraco/">Umbraco</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Visual Studio/">Visual Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Windbg/">Windbg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/category/Windows/">Windows</a></li></ul>

					
				</div>

				<div class="archive aside">
					<span class="sectiontitle">ARCHIVE</span>
					<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archive/2014">2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2013">2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2012">2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2011">2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2010">2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2009">2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2008">2008</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2007">2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archive/2006">2006</a></li></ul>
				</div>
			</div>

			<div class="clear"></div>
		</div>
		
		<footer>
			<div class="wrapper">Copyright &copy; 2014 Mark S. Rasmussen</div>
		</footer>

		<script type="text/javascript">
			$(function () {
				// Show mobile menu
				$("li.navicon").click(function () {
					if ($("header ul.mobile a").length == 0) {
						// Pages
						$mobilePages = $("div#naviconcontent ul.pages");
						$("header nav ul.normal > li").not(".navicon").each(function (i, el) {
							$mobilePages.append($(el).clone());
						});

						// Categories
						$mobileCategories = $("div#naviconcontent ul.categories");
						$("div#asides div.categories > ul > li").each(function (i, el) {
							$mobileCategories.append($(el).clone());
						});

						// Archive
						$mobileArchive = $("div#naviconcontent ul.archive");
						$("div#asides div.archive > ul > li").each(function (i, el) {
							$mobileArchive.append($(el).clone());
						});
					};

					$("header ul.mobile").toggle();
				});

				// Fancybox setup
				$("a.fancy").fancybox({
					hideOnContentClick: true,
					overlayShow: true
				});
			});
		</script>
	</body>
</html>